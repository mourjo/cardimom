let xml = `<feed xmlns="http://www.w3.org/2005/Atom">
<generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
<link href="https://otee.dev/feed.xml" rel="self" type="application/atom+xml"/>
<link href="https://otee.dev/" rel="alternate" type="text/html"/>
<updated>2021-08-24T06:54:18+00:00</updated>
<id>https://otee.dev/feed.xml</id>
<title type="html">Otee</title>
<subtitle>Personal site!</subtitle>
<entry>
<title type="html">Crisp: A Simple Lisp Interpreter</title>
<link href="https://otee.dev/2021/08/24/crisp-a-simple-lisp-interpreter.html" rel="alternate" type="text/html" title="Crisp: A Simple Lisp Interpreter"/>
<published>2021-08-24T00:00:00+00:00</published>
<updated>2021-08-24T00:00:00+00:00</updated>
<id>https://otee.dev/2021/08/24/crisp-a-simple-lisp-interpreter</id>
<content type="html" xml:base="https://otee.dev/2021/08/24/crisp-a-simple-lisp-interpreter.html"><p>In this post, I discuss about building a simple Lisp interpreter, written in JavaScript, supporting basic Clojure syntax.</p> <h2 id="infix-expressions-and-operator-precedence">Infix Expressions and Operator Precedence</h2> <p>In arithmetic expressions, the operator is always placed <em>in between</em> the operands. For example, an expression to multiply <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">3</code> and <code class="language-plaintext highlighter-rouge">4</code> would be written as follows: <code class="language-plaintext highlighter-rouge">2 * 3 * 4</code>. Because the operator is sandwiched between operands, these expressions are also called <strong>infix</strong> expressions.</p> <p>But when there are different operators in a single expression, it can result in some confusion. Take, for example, the expression, <code class="language-plaintext highlighter-rouge">2 * 3 + 4</code>. If <code class="language-plaintext highlighter-rouge">2</code> and <code class="language-plaintext highlighter-rouge">3</code> are multiplied first and then <code class="language-plaintext highlighter-rouge">4</code> is added, the result would be <code class="language-plaintext highlighter-rouge">10</code>. However, if <code class="language-plaintext highlighter-rouge">3</code> and <code class="language-plaintext highlighter-rouge">4</code> are added first and then multiplied by <code class="language-plaintext highlighter-rouge">2</code>, the result would be <code class="language-plaintext highlighter-rouge">14</code>.</p> <p>To prevent this kind of confusion, there is a collection of rules, called <strong>operator precedence</strong>, that have evolved ever since the introduction of algebraic notation, that dictate the order of precedence among operators. These rules are often abbreviated as BEMDAS, to signify the order among some of the common operators: Brackets, Exponents, Multiplication, Division, Addition, and Subtraction.</p> <p>Just like in arithmetic expressions, it can get equally confusing for the compiler of a programming language to evaluate expressions with multiple operations. To this end, most programming languages come with their own rules regarding operator precedence, to ensure consistency and uniformity, while executing programs. For example, in the case of JavaScript, the assignment operator has one of the lowest precedence while expressions inside a grouping operator (<code class="language-plaintext highlighter-rouge">( )</code>) have the highest precedence, meaning that sub-expressions that are grouped inside a pair of parentheses will be evaluated before the rest of the expression.</p> <h2 id="prefix-and-postfix-expressions">Prefix and Postfix Expressions</h2> <p>Clearly, operator precedence is a set of rules which are necessary to avoid the confusion that results from reading an infix expression. This makes prior knowledge of operator precedence vital: if one does not have prior knowledge of operator precedence, one cannot correctly evaluate an expression. Is there a way to represent expressions that does not rely on operator precedence to be evaluated?</p> <p>There are two alternatives to infix expressions: <strong>prefix</strong> and <strong>postfix</strong> expressions. In a prefix expression, the operator is written <em>before</em> the operands. Thus, the expression <code class="language-plaintext highlighter-rouge">2 * 3 + 4</code> would be expressed as <code class="language-plaintext highlighter-rouge">+ 4 * 2 3</code> This clarifies that the multiplication operation should be applied on <code class="language-plaintext highlighter-rouge">2</code> and <code class="language-plaintext highlighter-rouge">3</code> and their result should be added to <code class="language-plaintext highlighter-rouge">4</code>. A prefix expression removes any ambiguity regarding the application of operators on operands. This removes the need for developing elaborate conventions or rules to dictate operator precedence.</p> <p>Similar to a prefix expression, in a postfix expression, the operator is placed <em>after</em> the set of operands. Thus, the above expression would be expressed as: <code class="language-plaintext highlighter-rouge">2 3 * 4 +</code>.</p> <h2 id="s-expressions">S-expressions</h2> <p>Given the advantages of prefix expressions over traditional infix expressions, some programming languages solely rely on them to write logic. Typically, in such programming languages, expressions are divided into one or more ‘parts’ or ‘blocks’. Each such part or block will be contained within a pair of parentheses. Such expressions are called <strong>s-expressions</strong>. Thus, s-expression is a special kind of prefix expression, where every operation is contained within a pair of parentheses. Much like arithmetic expressions, it is possible to have nested expressions in a single s-expression.</p> <p>An s-expression essentially contains two building blocks: <strong>lists</strong> and <strong>atoms</strong>. An <strong>atom</strong> is the basic unit of the expression which is not divisible any further. Each atom is differentiated from another by the use of spaces. In the above examples, the numbers <code class="language-plaintext highlighter-rouge">2</code> <code class="language-plaintext highlighter-rouge">3</code> and <code class="language-plaintext highlighter-rouge">4</code> are atoms. Other data-types, like strings and <code class="language-plaintext highlighter-rouge">boolean</code> values can also be an atom. A variable can also be an atom.</p> <p>A <strong>List</strong> refers to each block or segment of an s-expression which is contained within a pair of parentheses. The first atom in the list signifies a function or an operator. Thus, if <code class="language-plaintext highlighter-rouge">f</code> represents a function and <code class="language-plaintext highlighter-rouge">args</code> represent its arguments, the syntax of a list can be represented as follows: <code class="language-plaintext highlighter-rouge">(f arg1 arg2 ... argn)</code>. Following this syntax, a simple list would be <code class="language-plaintext highlighter-rouge">(+ 1 2)</code>. A list can be nested inside another list. Thus, a list can be composed of one or more atoms and/or other lists.</p> <p>Here’s a list of valid s-expressions:</p> <p><img src="/assets/images/valid_expressions_crisp.png" alt="Table of valid expressions" width="100%" /></p> <h2 id="lisp">Lisp</h2> <p>Lisp was the first programming language to follow this “<em><a href="https://en.wikipedia.org/wiki/Lisp_(programming_language)">fully parenthesized prefix notation</a></em>” (s-expressions). Lisp, which is loosely derived from the term “List Processor”, was developed by <a href="http://jmc.stanford.edu/articles/lisp/lisp.pdf">John McCarthy in 1960</a>. Thereafter, many flavors and dialects of Lisp have emerged. Of these, Common Lisp and Clojure are two of the most well-known dialects of Lisp.</p> <p>Clojure is highly prevalent in modern times as seen in the latest <a href="https://insights.stackoverflow.com/survey/2021#technology-top-paying-technologies">Stackoverflow survey</a>. It is a programming language built on top of Java which provides a Lisp syntax for writing programs. The dialect of Lisp for which this project is building an interpreter for, relies on part of the Clojure syntax.</p> <h2 id="goal">Goal</h2> <p>The goal of this project is to write a tiny version of the Clojure REPL, which can perform certain basic mathematical operations.</p> <p>REPL stands for read-eval-print-loop. It refers to an interactive programming environment, that takes an input from the user, evaluates it and prints the result. Once a result is printed, the environment goes back to the read state to accept fresh inputs from the user, thereby creating a loop. The shell prompt on Unix-based systems is like a REPL.</p> <h2 id="scope">Scope</h2> <p>The project will evaluate <strong>valid s-expressions</strong>. If expressions are incomplete (eg., unclosed parenthesis) or if they are not written as per the syntax of an s-expression, an appropriate error message will be displayed.</p> <p>For the sake of simplicity, the project supports only <strong>basic mathematical operations</strong>, namely, multiplication, division, addition and subtraction. Thus, any s-expression containing any of these operations will be treated as valid. However, if an expression contains any other operator, the entire expression will be treated as invalid.</p> <p>The project also <strong>handles variables</strong>. To initialize a variable, the keyword <code class="language-plaintext highlighter-rouge">def</code> should be used. This keyword acts as an operator and accepts the following two arguments: name of the variable and its value. Here’s how variables can be initialized: <code class="language-plaintext highlighter-rouge">(def nameOfVariable 9)</code>. The same variable can be re-initialized with a new value in a single s-expression. Further, during a REPL session, once a variable has been initialized in one s-expression, it can be re-used in subsequent s-expressions.</p> <p>An s-expression may contain two disjointed s-expressions, such that there is more than one resultant value at the end of evaluation. For example, in the following expression, <code class="language-plaintext highlighter-rouge">(+ 7 8) (* 1 10)</code>, there are two values: <code class="language-plaintext highlighter-rouge">15</code> and <code class="language-plaintext highlighter-rouge">10</code>. The project is implemented to only display the <strong>right-most result</strong>. In the above example, <code class="language-plaintext highlighter-rouge">10</code> will be displayed.</p> <h2 id="running-the-project">Running the Project</h2> <p>To run the code of this project, <a href="https://github.com/oitee/crisp">this Github Repository</a> will need to be cloned:</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone git@github.com:oitee/crisp.git </code></pre></div></div> <p>The necessary dependencies to run the project needs to be installed:</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm <span class="nb">install</span> </code></pre></div></div> <p>To run the project (<a href="http://nodejs.dev/">Node.js</a> needs to be installed):</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm run repl </code></pre></div></div> <h2 id="demo">Demo</h2> <p>Here’s a live in-browser demo of the project, compiled from Node.js using webpack and babel:</p> <div id="outputdiv" style="height: 110px; overflow: scroll; border: 1px solid black; width: 100%"> </div> <p><input placeholder="Type Lisp expression" type="text" id="userinput" style="width: 100%" /></p> <script> !function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.crisp=e():t.crisp=e()}(self,(function(){return(()=>{"use strict";var t={d:(e,r)=>{for(var n in r)t.o(r,n)&&!t.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:r[n]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};function r(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}t.r(e),t.d(e,{lisp:()=>c});var o=function t(e){n(this,t),this.data=e,this.next=null},i=function(){function t(){n(this,t),this.head}var e,i;return e=t,(i=[{key:"isEmpty",value:function(){return null==this.head}},{key:"push",value:function(t){if(this.isEmpty())return this.head=new o(t),this.head.data;var e=new o(t);return e.next=this.head,this.head=e,this.head.data}},{key:"pop",value:function(){if(this.isEmpty())throw"Underflow";var t=this.head.data;return this.head=this.head.next,t}},{key:"peek",value:function(){if(this.isEmpty())throw"Empty stack";return this.head.data}}])&&r(e.prototype,i),t}();"0".charCodeAt(0),"9".charCodeAt(0),"a".charCodeAt(0),"z".charCodeAt(0),"A".charCodeAt(0),"Z".charCodeAt(0);var a={};function u(t){if("number"==typeof t)return t;if(a.hasOwnProperty(t))return a[t];throw"Operand is not a number: "+t}var f={"*":function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return u(t)*u(e)},"+":function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return u(t)+u(e)},"/":function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return u(t)/u(e)},"-":function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return u(t)-u(e)},def:function(t,e){if(!function(t){return"string"==typeof t}(t))throw"Variable name is not a string: "+t;return a[t]=u(e),u(e)}};function h(t){if(function(t){return f.hasOwnProperty(t)}(t))return t;if("number"==typeof t)return t;var e="-".charCodeAt(0),r="0".charCodeAt(0),n="9".charCodeAt(0),o=t.charCodeAt(0),i=0;if(o===e||o>=r&&o<=n){var a=0,u=!1;for(o===e&&(u=!0,a++);a<t.length;a++){if(!((o=t[a].charCodeAt(0))>=r&&o<=n))throw"Incompatible types: "+t;i=10*i+(o-r)}return u?-i:i}return t}function s(t){if(0==t.length)throw"Empty expression is invalid";for(var e=0;e<t.length;e++)t[e]=h(t[e]);for(var r=function(t){if(f.hasOwnProperty(t))return f[t];throw"Invalid operator: "+t}(t[t.length-1]),n=[],o=t.length-2;o>=0;o--){if("number"!=typeof t[o]&&"string"!=typeof t[o])throw"Operand is not valid: "+t[o];n.push(t[o])}return function(t){for(var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],r=e[0],n=1;n<e.length;n++)r=t(r,e[n]);return r}(r,n)}function p(t,e){(null==e||e>t.length)&&(e=t.length);for(var r=0,n=new Array(e);r<e;r++)n[r]=t[r];return n}function c(t){if("string"!=typeof t)throw"Input is not a string "+str;for(var e=function(t){if(Array.isArray(t))return p(t)}(c=t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(c)||function(t,e){if(t){if("string"==typeof t)return p(t,e);var r=Object.prototype.toString.call(t).slice(8,-1);return"Object"===r&&t.constructor&&(r=t.constructor.name),"Map"===r||"Set"===r?Array.from(t):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?p(t,e):void 0}}(c)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}(),r=new i,n="",o=0;o<e.length;o++){var a=e[o];if(" "!=a&&")"!=a&&"\n"!=a)"("===a?(r.push(a),n=""):n+=a;else if(""!==n&&(r.push(n),n=""),")"===a){for(var u=[],f=r.pop();"("!==f;)u.push(f),f=r.pop();var h=s(u);null!=h&&r.push(h)}}for(var c,l=r.pop();!r.isEmpty();)if("("==r.pop())throw"Incomplete expression";if("number"==typeof l)return l;throw"Unexpected result"}return e})()})); function repl (){ const userInput = document.getElementById("userinput"); const outputDiv = document.getElementById("outputdiv"); let result=""; try { result = crisp.lisp(userInput.value); } catch(e) { result = "Error: " + e; } outputDiv.innerText += "> " + result + "\n"; userInput.value=""; outputDiv.scrollTop = outputDiv.scrollHeight; } const userinput = document.getElementById("userinput"); userinput.addEventListener("keydown", function(event) { if (event.key === "Enter") { repl(); }}); </script> <h2 id="implementation-details">Implementation details</h2> <h3 id="how-expressions-are-read">How expressions are read</h3> <p>The aim is to convert the input string (containing a sequence of characters) into a tree that expressly sets out the structure for evaluating each list in a valid expression. This is called <strong>LR parsing</strong>. To do this, the input string is read from left-to-right, without ever going back.</p> <p>While traversing through each character in an expression, each collection of characters forming an atom is grouped together. This can be achieved as spaces demarcate atoms from one another. Also, a closing parenthesis implies the end of an atom (as it is not mandatory to use a space between an operand and closing parenthesis).</p> <p>When an atom is parsed, it will be pushed to a stack. Once all the atoms of a list have been parsed and the list is complete, all the atoms belonging to that list will be popped from the stack. As every list is enclosed between a pair of parentheses, whenever a closing parenthesis is detected (while going from left-to-right of the input string), it would imply the end of a list. Thus, when a <code class="language-plaintext highlighter-rouge">)</code> is detected, all the atoms pushed to the stack (thus far) will be popped out of the stack. As only the atoms of the current list should be popped, the popping should stop the moment a <code class="language-plaintext highlighter-rouge">(</code> is popped. This would signify the beginning of the current list.</p> <p>Once all the atoms of a list are popped, the list is evaluated. This is done by passing the collection of atoms comprising the list to an evaluator function. This function will first interpret the meaning of each atom. For example, if an atom contains digits, it will call the appropriate function to convert that atom into an integer. Similarly, it will convert the operator symbol to its corresponding function. Once this process is complete, it will call the relevant operator function and pass the set of operands belonging to the current list. The return value will be pushed back into the stack.</p> <p>In this way, a <strong>syntax tree</strong> will be created incrementally and from bottom-up. For example, if the input expression is <code class="language-plaintext highlighter-rouge">(* 1 (* 5 6) (+ 7 8 9) 10)</code> , the atoms and lists will be built as follows:</p> <p>First, the <code class="language-plaintext highlighter-rouge">*</code> operator will be pushed to the stack, along with the opening parenthesis <code class="language-plaintext highlighter-rouge">(</code>. Then, the following atoms will be pushed: <code class="language-plaintext highlighter-rouge">1</code> <code class="language-plaintext highlighter-rouge">(</code> <code class="language-plaintext highlighter-rouge">*</code> <code class="language-plaintext highlighter-rouge">5</code> and <code class="language-plaintext highlighter-rouge">6</code>. (For the sake of simplicity, the parentheses are not shown on the syntax tree).</p> <p><img src="/assets/images/syntax_tree_stack_1.png" alt="Syntax Tree and stack 1" width="100%" /></p> <p>Now that there is a <code class="language-plaintext highlighter-rouge">)</code>, it will signify the end of the current list. So, all the atoms of the present list will be popped, namely <code class="language-plaintext highlighter-rouge">6</code> <code class="language-plaintext highlighter-rouge">5</code> <code class="language-plaintext highlighter-rouge">*</code> and <code class="language-plaintext highlighter-rouge">(</code>. In place of these atoms, the value of <code class="language-plaintext highlighter-rouge">(* 5 6)</code> will be pushed into the stack. The syntax tree would now look like this:</p> <p><img src="/assets/images/syntax_tree_stack_2.png" alt="Syntax Tree and stack 2" width="100%" /></p> <p>In a similar manner, the next set of atoms will be pushed, i.e., <code class="language-plaintext highlighter-rouge">(</code> <code class="language-plaintext highlighter-rouge">+</code> <code class="language-plaintext highlighter-rouge">7</code> <code class="language-plaintext highlighter-rouge">8</code> <code class="language-plaintext highlighter-rouge">9</code> will be pushed:</p> <p><img src="/assets/images/syntax_tree_stack_3.png" alt="Syntax Tree and stack 3" width="100%" /></p> <p>Again, the presence of <code class="language-plaintext highlighter-rouge">)</code> would signify the end of the current list. So, all the atoms of this list will be popped and their result will be pushed into the stack. Finally, the penultimate atom, <code class="language-plaintext highlighter-rouge">10</code> will be pushed and then all the remaining values in the stack will be passed to the multiplication operator along with <code class="language-plaintext highlighter-rouge">1</code>.</p> <p><img src="/assets/images/syntax_tree_stack_4.png" alt="Syntax Tree and stack 4" width="100%" /></p> <p>Now that there is no other element left in the expression, the return value of this function call will be the final output, i.e., <code class="language-plaintext highlighter-rouge">7200</code>.</p> <h3 id="system-design">System Design</h3> <p><img src="/assets/images/system_design_crisp.png" alt="System Design" width="100%" /></p> <p>The project can be divided into three main components:</p> <p><strong>REPL:</strong> REPL runs the interactive environment. It accepts inputs from the user, passes it to the parser component and displays the final result, once it is generated.</p> <p><strong>Parser:</strong> The parser component parses each atom from the input string, by going from left-to-right. Each atom is stored in a stack data-structure. Once a list is formed, it transfers all the atoms of that list from the stack to the evaluator component. The value generated by the evaluator is pushed into the stack.</p> <p><strong>Evaluator:</strong> The evaluator component receives all the atoms of each list in the input expression. It checks if any of the atoms contains any digits and converts them into integers, accordingly. It converts the operator symbols and intialised variables to their respective values. Once each atom in a list has been tokenized, it evaluates the list expression and returns the result.</p> <h2 id="further-improvements">Further Improvements</h2> <p>Lisps are vast and have many features that are not implemented in this tiny project. The goal was to have a first version of a Lisp interpreter that could do the basic operations. Some of the main missing features that could be the first to be added to this are:</p> <ul> <li> <p><strong>Local scoping:</strong> While the project supports initialization and re-initialization of variables, it does not support initialization of local variables, within a given scope. For example, in Clojure, the keyword <code class="language-plaintext highlighter-rouge">let</code> allows for initialization of local variables within a given lexical context. The project does not support this feature.</p> </li> <li> <p><strong>User defined functions:</strong> The project does not support function parsing. The program is built only to execute predefined operators. There is no scope to add new operators.</p> </li> </ul> <p>The project is hosted on this <a href="https://github.com/oitee/crisp">GitHub repository</a>. Pull requests for the above improvements (or anything else) would be highly appreciated!</p></content>
<author>
<name/>
</author>
<category term="programming"/>
<summary type="html">In this post, I discuss about building a simple Lisp interpreter, written in JavaScript, supporting basic Clojure syntax.</summary>
</entry>
<entry>
<title type="html">Cache Replacement</title>
<link href="https://otee.dev/2021/08/18/cache-replacement-policy.html" rel="alternate" type="text/html" title="Cache Replacement"/>
<published>2021-08-18T00:00:00+00:00</published>
<updated>2021-08-18T00:00:00+00:00</updated>
<id>https://otee.dev/2021/08/18/cache-replacement-policy</id>
<content type="html" xml:base="https://otee.dev/2021/08/18/cache-replacement-policy.html"><p>It is said that “There are <a href="https://twitter.com/codinghorror/status/506010907021828096">two hard things in computer science</a>: cache invalidation, naming things, and off-by-one errors.” This post will be on the first one.</p> <p>In this post, I attempt to discuss what the term ‘cache’ actually means and delve into some of the common cache replacement policies. Also, inspired by this <a href="https://github.com/clojure/core.cache">Clojure repository</a> on Github, I attempt to implement some of the common cache replacement policies.</p> <h2 id="what-is-cache">What is cache?</h2> <p>Cache refers to the storage of data that is likely to be requested in the future. When an application needs to access some data (which is expected to be cached), it will first check if that data exists in its cache. If yes, it will simply retrieve that data and access it. Otherwise, it will generate that data, which will be stored in the cache for a future request.</p> <p>When the data requested from a cache is successfully found, it is called a <em>cache hit</em>. On the other hand, a <em>cache miss</em> occurs when the requested data is not stored in the cache. In the event of a <em>cache miss</em>, the data will need to be computed or located from a slower data source, which will take much longer time to generate, than a <em>cache hit</em>. For example, a browser may download web-pages that are most-frequently used by the user. When requests for those web-pages are generated by the user, the browser can simply retrieve the downloaded pages which will be much faster than loading other web-pages which are not cached.</p> <p>Thus, it is clear that, ideally, the number of <em>cache hits</em> should, on an average, be greater than the number of <em>cache misses.</em> This makes the <strong>hit ratio of cache</strong> very crucial.</p> <h2 id="problem-with-unrestricted-memoization">Problem with unrestricted memoization</h2> <p>In a world with infinite resources to store infinite amount of data, we can achieve a near-perfect hit ratio, as we can keep populating our cache with the data generated from previous requests, thereby restricting <em>cache misses</em> to only those requests that have never been created before. In my <a href="https://otee.dev/2021/08/05/memoization.html">previous post on memoization</a>, <strong>I had implemented exactly this</strong>.</p> <p>Recall that memoization refers to the storage of return values of previous function-calls. I had implemented memoization such that whenever a memoized function was called with a given set of arguments, that function would first check if a return value for that set of arguments already existed in a dictionary called <code class="language-plaintext highlighter-rouge">memo</code>. If the memo did not contain the return value, it would compute the value by calling the actual function, and <strong>then <em>indiscriminately</em> store that value against the set of arguments</strong>, before returning the value back to the caller. In this way, we simply stored <em>each and every input and return values</em> of a memoized function.</p> <p>This approach proved to be particularly effective with functions which recursively called itself more than once (such as a function to generate the nth Fibonacci number). But, inadvertently, the memo dictionary (storing the return values), kept growing with each new set of inputs. For example, when we call the memoized Fibonacci function with <code class="language-plaintext highlighter-rouge">50</code> as an argument, the memo would store the return values of every integer from <code class="language-plaintext highlighter-rouge">0</code> till <code class="language-plaintext highlighter-rouge">50</code>. This is not ideal, because when dealing with larger data-sets and more complicated algorithms, <strong>we will not have the luxury to store each and every return value</strong>.</p> <h2 id="cache-replacement-algorithms">Cache Replacement Algorithms</h2> <p>There will always be a trade-off between the size of the cache and the speed of returning a data. Of course, a bigger cache can contain greater amount of data, thereby reducing the chances of re-computation. On the other hand, there will always be practical limitations of the total amount of memory we can allocate to the cache of a particular program.</p> <p>Thus, given a specific size of a cache, when we reach that maximum capacity, we will need to <em>replace</em> or <em>evict</em> an existing item in the cache in order to add a new item to it. To increase efficiency of a program, we need to find the most optimum way to add and replace items in a cache, <strong>such that the item that will be least likely to be requested again is always replaced</strong> by an item that has a greater likelihood of a future request. This strategy is known as <strong>Bélády’s algorithm</strong>. Clearly, to achieve this, we need to be aware of the nature of future requests.</p> <p>In the case of recursive calls, we can easily estimate the nature of future (recursive) calls. Take the example of the function returning the <code class="language-plaintext highlighter-rouge">n</code>th Fibonacci number [f(n) = f(n - 2) + f(n - 1)]. To find the <code class="language-plaintext highlighter-rouge">n</code>th Fibonacci number, we need to call the same function for <code class="language-plaintext highlighter-rouge">(n - 2)</code> and for <code class="language-plaintext highlighter-rouge">(n - 1)</code>. This will continue till <code class="language-plaintext highlighter-rouge">n == 0 || n == 1</code>, in which case it will return <code class="language-plaintext highlighter-rouge">n</code>.</p> <p>In this case, we can reach the optimum strategy proposed by Bélády, if we create a cache which can store just two items, such that <strong>each new return value is added to the cache by evicting the older of the remaining values in the cache</strong>. To illustrate how this works, it is important to note in the case of recursive calls, the final value is reached by going up the chain of recursive calls starting with the base-case. Thus, the cache will initially store the values of the <code class="language-plaintext highlighter-rouge">n = 0</code> and <code class="language-plaintext highlighter-rouge">n = 1</code>, which are the two base cases of the present function. When <code class="language-plaintext highlighter-rouge">n = 2</code>, the cache contains the return values of f(1) and f(2). To find the 2nd Fibonacci number, we need to know the values of f(2 - 2) and f(2 - 1). Both these values are already stored in the cache, so we will not need to compute either of these values. But, now that we have a new return value, i.e., f(2), it will be added to the cache, and the value of f(0) will be evicted. Now, when <code class="language-plaintext highlighter-rouge">n = 3</code>, the cache contains the values of f(1) and f(2), relying on which, the return value of f(3) can be generated. Again, the return value of f(3) will be replacing the return value of f(1). This will continue till we reach n. In the following table, this process has been illustrated for a case when n = 7.</p> <p><img src="/assets/images/cache_eviction_fibonacci.jpg" alt="Finding the 7th Fibonacci number, using a cache-size of 2 element" /></p> <p>However, unlike recursive calls, in most cases, it is impossible to predict the nature of future calls or requests for data. Thus, it is not practically possible to write a cache replacement algorithm that can achieve the same level of efficiency as proposed by Bélády. Instead, <strong>we write approximation algorithms based on certain parameters</strong> (such as order of insertion, recency and frequency of access etc), which can increase the <em>cache hit</em> probabilities for a given program.</p> <p>Following are some of the common and simpler types of cache replacement policies:</p> <ul> <li><strong>First-in-first-out (FIFO) policy</strong>: The earliest inserted item in the cache will be evicted when a new item needs to be inserted.</li> <li><strong>Last-in-first-out (LIFO) policy</strong>: The last item inserted in the cache will be evicted first.</li> <li><strong>Least-recently used (LRU) policy</strong>: The item which is least recently used will be evicted first. This is one of the most simple and common cache replacement policies. It assumes that the more recently an item is accessed or used, the more likely it is to be used or accessed again (e.g., switching between tabs of a browser)</li> <li><strong>Most-recently used (MRU) policy</strong>: The item which is most recently used will be evicted first. This policy is useful, when the chances of repeating the same request in the near future is unlikely (like scrolling through a social media feed or flipping through a photo album).</li> <li><strong>Least-frequently-used(LFU) policy:</strong> The cache algorithm maintains a counter on the number of times an item in the cache is accessed. It will evict the least frequently accessed item in order to add a new item.</li> <li><strong>Time-to-live (TTL) policy:</strong> If an item remains in the cache beyond a given period of time without being accessed, the cache algorithm would discard it, to make room for a new item. Morever, if the size of the cache needs to be bounded, another cache replacement policy can be applied on top of TTL. For example, if there is no item in the cache which has exceeded the given time-period, the least frequently used item (LFU) may be evicted to insert a new item.</li> <li><strong>Random replacement (RR) policy</strong>: The cache algorithm randomly selects an item to evict.</li> </ul> <h3 id="implementing-lru-policy">Implementing LRU Policy</h3> <p>To implement LRU policy, we can write a function that accepts any function (which will carry out the actual task) and returns a memoized version of the same function. This returned function will first check if, for a given set of parameters, a return value exists in the respective cache object. If yes, it will access the value. Otherwise, it will compute the return value and store its value in the cache object.</p> <p>In addition to the cache object, the function should maintain another object which will keep a counter for each time a value is accessed or entered into the cache. This object will contain the same set of keys as the cache object. But the value of these keys will represent how recently they were inserted or accessed by the function.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">lru</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span> <span class="kd">let</span> <span class="nx">cache</span> <span class="o">=</span> <span class="p">{};</span> <span class="kd">let</span> <span class="nx">accessed</span> <span class="o">=</span> <span class="p">{};</span> <span class="kd">let</span> <span class="nx">counterCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">return</span> <span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="nx">cache</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">args</span><span class="p">))</span> <span class="p">{</span> <span class="nx">accessed</span><span class="p">[</span><span class="nx">args</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="nx">counterCount</span><span class="p">;</span> <span class="k">return</span> <span class="nx">cache</span><span class="p">[</span><span class="nx">args</span><span class="p">];</span> <span class="p">}</span> <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">f</span><span class="p">(...</span><span class="nx">args</span><span class="p">);</span> <span class="k">if</span> <span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">cache</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="kd">let</span> <span class="nx">least</span> <span class="o">=</span> <span class="nx">counterCount</span><span class="p">;</span> <span class="kd">let</span> <span class="nx">candidateKey</span><span class="p">;</span> <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="k">in</span> <span class="nx">accessed</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="nx">accessed</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">least</span><span class="p">)</span> <span class="p">{</span> <span class="nx">least</span> <span class="o">=</span> <span class="nx">accessed</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">candidateKey</span> <span class="o">=</span> <span class="nx">key</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span> <span class="k">delete</span> <span class="nx">cache</span><span class="p">[</span><span class="nx">candidateKey</span><span class="p">];</span> <span class="k">delete</span> <span class="nx">accessed</span><span class="p">[</span><span class="nx">candidateKey</span><span class="p">];</span> <span class="p">}</span> <span class="nx">cache</span><span class="p">[</span><span class="nx">args</span><span class="p">]</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span> <span class="nx">accessed</span><span class="p">[</span><span class="nx">args</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="nx">counterCount</span><span class="p">;</span> <span class="k">return</span> <span class="nx">result</span><span class="p">;</span> <span class="p">};</span> <span class="p">}</span> </code></pre></div></div> <p>In the above example, the function <code class="language-plaintext highlighter-rouge">lru</code> creates two objects, <code class="language-plaintext highlighter-rouge">cache</code> (for storing the return values of each set of arguments) and <code class="language-plaintext highlighter-rouge">accessed</code> (for storing the counter values of each accessed item in the cache). If a return value exists within <code class="language-plaintext highlighter-rouge">cache</code>, that value is fetched and returned to the caller. But, before returning the value, the corresponding value for that set of arguments in <code class="language-plaintext highlighter-rouge">accessed</code> is updated. If a return value is not present, the actual function is called. The return value is stored in the <code class="language-plaintext highlighter-rouge">cache</code>. Before storing the new item, it is checked if the size of <code class="language-plaintext highlighter-rouge">cache</code> has already exceeded its maximum capacity (here, it has been kept as <code class="language-plaintext highlighter-rouge">2</code>). If so, the set of arguments with the lowest counter value in the <code class="language-plaintext highlighter-rouge">accessed</code> object is fetched. This set of arguments is deleted from both <code class="language-plaintext highlighter-rouge">cache</code> and <code class="language-plaintext highlighter-rouge">accessed</code> before the new return value is stored in the <code class="language-plaintext highlighter-rouge">cache</code>.</p> <h2 id="separating-out-the-cache-eviction">Separating out the Cache Eviction</h2> <p>In the above implementation, it is clear that we will need to write separate functions for each type of cache eviction policy. More significantly, the memoization, computation and implementation of the cache algorithm are all taking place together in the same function, which is why we need to write an altogether new function if we want to implement a new policy for replacing cache. This is a limitation.</p> <p>It would be more idomatic if we separate out the cache eviction algorithm from the rest of the function. This will give liberty to the user to choose a specific cache algorithm while memoizing a given function. To do this, we can write separate classes for implementing different cache algorithms. Objects created by this class will contain three methods (which carry out operations as per the rules of the corresponding cache eviction policies):</p> <ul> <li><strong>has:</strong> This method will be used to look-up if the cache object contains the return values of a specific set of arguments</li> <li><strong>hit:</strong> This method will be invoked when we know that the cache object contains a specific return value. This method will return the value. It can also carry out necessary operations (if any), required to be carried out while accessing an item in the cache. For example, in an LRU cache algorithm, the <code class="language-plaintext highlighter-rouge">hit</code> method will update the counter value of the set of arguments, before returning its values.</li> <li><strong>miss:</strong> This method will be invoked when we know that the cache object does not contain the specific input. It will accept two parameters: i) the set of arguments, and ii) its corresponding return value. This method will be responsible for updating the cache, as per the corresponding cache eviction policy.</li> </ul> <p>Thus, the LRU policy can be implemented by creating a new class called <code class="language-plaintext highlighter-rouge">LruCache</code> as shown below:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//class for all creating cache objects</span> <span class="c1">//following LRU policy</span> <span class="kd">class</span> <span class="nx">LRUCache</span> <span class="p">{</span> <span class="kd">constructor</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">=</span> <span class="nx">n</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">table</span> <span class="o">=</span> <span class="p">{};</span> <span class="k">this</span><span class="p">.</span><span class="nx">accessed</span> <span class="o">=</span> <span class="p">{};</span> <span class="k">this</span><span class="p">.</span><span class="nx">counterCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="nx">has</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">table</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="p">}</span> <span class="nx">hit</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">accessed</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="k">this</span><span class="p">.</span><span class="nx">counterCount</span><span class="p">;</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">table</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="p">}</span> <span class="nx">miss</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">table</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span> <span class="p">{</span> <span class="kd">let</span> <span class="nx">least</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">counterCount</span><span class="p">;</span> <span class="kd">let</span> <span class="nx">candidateKey</span><span class="p">;</span> <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">k</span> <span class="k">in</span> <span class="k">this</span><span class="p">.</span><span class="nx">accessed</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">accessed</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">least</span><span class="p">)</span> <span class="p">{</span> <span class="nx">least</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">accessed</span><span class="p">[</span><span class="nx">k</span><span class="p">];</span> <span class="nx">candidateKey</span> <span class="o">=</span> <span class="nx">k</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span> <span class="k">delete</span> <span class="k">this</span><span class="p">.</span><span class="nx">table</span><span class="p">[</span><span class="nx">candidateKey</span><span class="p">];</span> <span class="k">delete</span> <span class="k">this</span><span class="p">.</span><span class="nx">accessed</span><span class="p">[</span><span class="nx">candidateKey</span><span class="p">];</span> <span class="p">}</span> <span class="k">this</span><span class="p">.</span><span class="nx">table</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">accessed</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="o">++</span><span class="k">this</span><span class="p">.</span><span class="nx">counterCount</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span> <span class="c1">//Creating a new cache object</span> <span class="c1">//by invoking LRUCache</span> <span class="kd">let</span> <span class="nx">lruCacheForFibo</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LRUCache</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="c1">//Memoizing function:</span> <span class="c1">// It will invoke has(), hit() and miss() of the cache object </span> <span class="kd">function</span> <span class="nx">cacheThisFunction</span><span class="p">(</span><span class="nx">cache</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="nx">cache</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">args</span><span class="p">))</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">hit</span><span class="p">(</span><span class="nx">args</span><span class="p">);</span> <span class="p">}</span> <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">args</span><span class="p">);</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">miss</span><span class="p">(</span><span class="nx">args</span><span class="p">,</span> <span class="nx">result</span><span class="p">);</span> <span class="k">return</span> <span class="nx">result</span><span class="p">;</span> <span class="p">};</span> <span class="p">}</span> <span class="c1">//Calling the above function to memoise the Fibonacci function</span> <span class="kd">let</span> <span class="nx">memoizedFiboLru</span> <span class="o">=</span> <span class="nx">cacheThisFunction</span><span class="p">(</span><span class="nx">lruCacheForFibo</span><span class="p">,</span> <span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">n</span><span class="p">;</span> <span class="p">}</span> <span class="k">return</span> <span class="nx">memoizedFiboLru</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nx">memoizedFiboLru</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="p">});</span> </code></pre></div></div> <p>The above example contains three parts:</p> <ul> <li>A class that creates cache objects containing the respective <code class="language-plaintext highlighter-rouge">has</code> <code class="language-plaintext highlighter-rouge">hit</code> and <code class="language-plaintext highlighter-rouge">miss</code> methods</li> <li>A function that accepts another function and a cache object. This function returns a memoized version of the function that was passed to it. Importantly, <strong>the definition or logic of this memoizing function will not need to change with different caching algoritms</strong> being implemented by the cache object.</li> <li>The memoized function first checks if the arguments passed to it exists in the relevant cache object. This is done by invoking <code class="language-plaintext highlighter-rouge">has</code>. If the <code class="language-plaintext highlighter-rouge">has</code> method returns <code class="language-plaintext highlighter-rouge">true</code>, the <code class="language-plaintext highlighter-rouge">hit</code> method is invoked which returns the value stored in the cache object. If the <code class="language-plaintext highlighter-rouge">has</code> method returns <code class="language-plaintext highlighter-rouge">false</code>, the underlying function (which has been memoized) is called. Then, the return value so computed is passed to the <code class="language-plaintext highlighter-rouge">miss</code> method along with the set of arguments, to store the same inside the cache object.</li> </ul> <p>Clearly, the memoizing function can now be used on <em>any function with any number of arguments</em> and on <em>any cache implementing any cache eviction policy</em>. Essentially, we have abstracted out the implementation of the cache eviction policy from the rest of the memoization function.</p> <p>The above technique can be used in a similar manner to implement other cache eviction policies as well. In the following example, the random replacement policy is implemented:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">RRCache</span> <span class="p">{</span> <span class="kd">constructor</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span> <span class="o">=</span> <span class="nx">n</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">table</span> <span class="o">=</span> <span class="p">{};</span> <span class="p">}</span> <span class="nx">has</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">table</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span> <span class="p">}</span> <span class="nx">hit</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">table</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="p">}</span> <span class="nx">miss</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">table</span><span class="p">).</span><span class="nx">length</span> <span class="o">&gt;=</span> <span class="k">this</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span> <span class="p">{</span> <span class="kd">let</span> <span class="nx">allKeys</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">table</span><span class="p">);</span> <span class="kd">let</span> <span class="nx">randomIndex</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="nx">allKeys</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span> <span class="kd">let</span> <span class="nx">randomKey</span> <span class="o">=</span> <span class="nx">allKeys</span><span class="p">[</span><span class="nx">randomIndex</span><span class="p">];</span> <span class="k">delete</span> <span class="k">this</span><span class="p">.</span><span class="nx">table</span><span class="p">[</span><span class="nx">randomKey</span><span class="p">];</span> <span class="p">}</span> <span class="p">}</span> <span class="p">}</span> <span class="kd">let</span> <span class="nx">fiboRandomCache</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">RRCache</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="kd">function</span> <span class="nx">cacheThisFunction</span><span class="p">(</span><span class="nx">cache</span><span class="p">,</span> <span class="nx">f</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="nx">cache</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">args</span><span class="p">))</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">hit</span><span class="p">(</span><span class="nx">args</span><span class="p">);</span> <span class="p">}</span> <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">f</span><span class="p">(...</span><span class="nx">args</span><span class="p">);</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">miss</span><span class="p">(</span><span class="nx">args</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span> <span class="k">return</span> <span class="nx">value</span><span class="p">;</span> <span class="p">};</span> <span class="p">}</span> <span class="kd">let</span> <span class="nx">memoizedFiboRandom</span> <span class="o">=</span> <span class="nx">cacheThisFunction</span><span class="p">(</span><span class="nx">fiboRandomCache</span><span class="p">,</span> <span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">n</span><span class="p">;</span> <span class="p">}</span> <span class="k">return</span> <span class="nx">memoizedFiboRandom</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nx">memoizedFiboRandom</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="p">});</span> </code></pre></div></div> <p>To see the implementation of the cache policies mentioned on this post (i.e., LIFO, FIFO, LRU, MRU, LFU, RR, TTL), please check out my <a href="https://github.com/oitee/cacheReplacement">GitHub repository on cache replacement</a>.</p></content>
<author>
<name/>
</author>
<category term="conceptual"/>
<summary type="html">It is said that “There are two hard things in computer science: cache invalidation, naming things, and off-by-one errors.” This post will be on the first one.</summary>
</entry>
<entry>
<title type="html">Implementing Graphs</title>
<link href="https://otee.dev/2021/08/13/implementing-graph.html" rel="alternate" type="text/html" title="Implementing Graphs"/>
<published>2021-08-13T00:00:00+00:00</published>
<updated>2021-08-13T00:00:00+00:00</updated>
<id>https://otee.dev/2021/08/13/implementing-graph</id>
<content type="html" xml:base="https://otee.dev/2021/08/13/implementing-graph.html"><p>A graph is an data structure consisting of a set of vertices, each of which are connected to one or more other vertices. In this post, I explore this data structure and implement some of its common operations.</p> <h2 id="what-is-a-graph">What is a graph</h2> <p>A graph is a data structure containing nodes or vertices which are optionally interlinked by edges or links. (In this post, the terms ‘vertex’ and ‘node’ will be used interchangeably. The terms ‘edges’ and ‘links’ will also be used interchangably).</p> <p>Graphs are powerful because they can be used to represent <em>any</em> form of relationship. For example, graphs can be used to represent road-systems in a city and relationships between different members on a social networking site.</p> <h4 id="graphs-and-trees">Graphs and trees</h4> <p>Trees represent hierarchical relations. They will always have a special node called root which may have one or more sub-trees. A tree is, in fact, a special kind of graph. A tree is graph without cycles. To put it in another way, in a graph, it is permissible to connect any vertex (irrespective of where they are) to any other vertex in the same graph. As there is no specific restriction or order in which vertices need to be connected to each other, there can be multiple paths (also called ‘edges’) between two given vertices. But, in the case of a tree, each node will have only one specific route to reach another.</p> <p><img src="/assets/images/tree_and_graph.jpg" alt="Image showing a graph with multiple paths" /></p> <h4 id="directed-and-undirected-graphs">Directed and Undirected Graphs</h4> <p>Graphs can be directed or undirected. In a directed graph, between two neighbours, only one will point to the other. But in an undirected graph, each neighbour will point to all of its neighbours. Thus, between two neighbouring vertices A and B, A will point to B and B will point to A.</p> <p>In other words, the connection or edge between two vertices can either be symmetric or asymmetric. For example, when a member (say, X) follows another member (say Y) on Twitter, their relationship is assymetric: only one of them follws the other. However, when X and Y become friends on the Facebook, both of them will become friends of each other, thereby having a symmetric relationship.</p> <p><img src="/assets/images/directed_and_undirected_graphs.jpg" width="60%" /></p> <p>A graph is called a connected graph, if every pair of vertices is connected to each other by at least one path. Both directed and undirected graphs can be connected or disconnected. Note that it is not necessary for a connected graph to have each of its pairs connected by a path of length 1. Pairs of vertices that are connected by a path of length one are called neighbours or adjacent vertices.</p> <p><img src="/assets/images/connected_and_unconnected_graphs.jpg" width="60%" /></p> <h2 id="representing-a-graph">Representing a graph</h2> <p>There are largely two ways of representing a graph:</p> <ul> <li><em>Adjacency matrix:</em> A graph having <em>n</em> nodes can be represented in an <em>n*n</em> matrix, such that, if there exists a path between two vertices (say, <em>i</em> and <em>j</em>), the [i][j] cell will be <code class="language-plaintext highlighter-rouge">true</code>, otherwise it will be <code class="language-plaintext highlighter-rouge">false</code>. If its an undirected graph, both the [i][j] and the [j][i] cells will be marked as <code class="language-plaintext highlighter-rouge">true</code> (or <code class="language-plaintext highlighter-rouge">false</code>, as the case may be). Instead of using boolean values, we can use <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">1</code> to represent the existence of a path. Sometimes edges can have weights, signifying some notion of cost or distance. This can be represented in the adjacency matrix (instead of using <code class="language-plaintext highlighter-rouge">1</code> for every edge).</li> <li><em>Adjacency list</em>: A graph can also be represented by maintaining an array for each vertex in that graph, such that, the array of each vertex stores a pointer to each of its immediate neighbouring vertices.</li> </ul> <p>An adjacency matrix is relatively more efficient to represent graphs which have a dense network of paths. It allows for quick look-up and updation of new paths. But, it also takes up substantial space, especially when the number of paths is relatively low. For example, in a graph representing a social networking site, the total number of users (vertices) may be in the millions, while each user may have only a few hundred connections(paths). If we use an adjacency matrix to represent this graph, a substantial majority of the cells of the matrix will be empty.</p> <p>An adjacency list is more useful to find out the degree (i.e., the number of immediate neighbours) of a particular vertex. It takes up less space than an adjacency matrix. However, to insert a new edge or delete an existing one, it takes more time than in an adjacency matrix.</p> <p><strong>Largely, adjacency lists are more convenient for programs dealing with sparse graphs (i.e., where the total number of vertices are comparatively greater than the total number of edges), while adjacency matrices are more useful for representing dense graphs.</strong> In this post, I will implement a graph using adjacency list.</p> <h2 id="implementing-a-graph">Implementing a graph</h2> <p>We need to first define a constructor function for a graph. As discussed above, the constructor function will need to create an array for each vertex, to store their adjacent vertices. Also, each vertex should store a specific value. The constructor will contain a method, that can be called whenever we want to add a neighbour to a specific vertex. There will be another method, to first check if a specific vertex is already a neighbour of a given vertex.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Graph</span> <span class="p">{</span> <span class="kd">constructor</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">neighbors</span> <span class="o">=</span> <span class="p">[];</span> <span class="p">}</span> <span class="nx">addNeighbors</span><span class="p">(...</span><span class="nx">neighborVertices</span><span class="p">)</span> <span class="p">{</span> <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">neighborVertices</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">isNeighbor</span><span class="p">(</span><span class="nx">neighborVertices</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">neighbors</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">neighborVertices</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="p">}</span> <span class="p">}</span> <span class="p">}</span> <span class="nx">isNeighbor</span><span class="p">(</span><span class="nx">candidateNode</span><span class="p">)</span> <span class="p">{</span> <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">neighbors</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">neighbors</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="nx">candidateNode</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span> </code></pre></div></div> <p>To create new vertices, we need to call the constructor <code class="language-plaintext highlighter-rouge">Graph</code> along with the <code class="language-plaintext highlighter-rouge">new</code> keyword. To add new neighbouring vertices to a given vertex, we need to add pointers to such vertices in the <code class="language-plaintext highlighter-rouge">.addNeigbors</code> method.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Graph</span><span class="p">(</span><span class="dl">"</span><span class="s2">A</span><span class="dl">"</span><span class="p">);</span> <span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Graph</span><span class="p">(</span><span class="dl">"</span><span class="s2">B</span><span class="dl">"</span><span class="p">);</span> <span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Graph</span><span class="p">(</span><span class="dl">"</span><span class="s2">C</span><span class="dl">"</span><span class="p">);</span> <span class="kd">let</span> <span class="nx">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Graph</span><span class="p">(</span><span class="dl">"</span><span class="s2">D</span><span class="dl">"</span><span class="p">);</span> <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Graph</span><span class="p">(</span><span class="dl">"</span><span class="s2">X</span><span class="dl">"</span><span class="p">);</span> <span class="nx">a</span><span class="p">.</span><span class="nx">addNeighbors</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">d</span><span class="p">);</span> <span class="nx">b</span><span class="p">.</span><span class="nx">addNeighbors</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span> <span class="nx">c</span><span class="p">.</span><span class="nx">addNeighbors</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">d</span><span class="p">);</span> <span class="nx">d</span><span class="p">.</span><span class="nx">addNeighbors</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">);</span> <span class="nx">x</span><span class="p">.</span><span class="nx">addNeighbors</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">d</span><span class="p">);</span> </code></pre></div></div> <h2 id="searching-a-graph">Searching a Graph</h2> <p>Traversing through every vertex of a graph is one of the most significant operations involving a graph, as it is the only way to determine, for example, if a graph contains a specific value, or if a graph is cyclical etc.</p> <p>There are two ways to traverse through a graph, as explained below.</p> <h4 id="depth-first-search">Depth-first Search</h4> <p>According to this method, we start with searching within a given vertex (which can be any arbitrarily chosen vertex, as it is not necessary to have a specific root node in a graph), and then <em>visit</em> any one of the neighbouring vertices of that vertex. Then, if that vertex has any neighbouring vertex, we visit any one such neighbour. We continue this, till we reach a vertex with no neighbours, that have not been visited already. Then, we trace back to the penultimate vertex, and visit another neighbour of that vertex. We continue this all the way upto the the first vertex. The traversal ends when either the specific value being searched for is found or till every single vertex has been scanned once. Thus, in a depth-first search, at the level of a given vertex, we will first <em>recursively visit the current node’s neighbours’ neighbours before visiting the current node’s other neighbours.</em></p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">vertex</span><span class="p">,</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">())</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">vertex</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span> <span class="nx">visited</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">vertex</span><span class="p">);</span> <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">vertex</span><span class="p">.</span><span class="nx">neighbors</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">vertex</span><span class="p">.</span><span class="nx">neighbors</span><span class="p">[</span><span class="nx">i</span><span class="p">]))</span> <span class="p">{</span> <span class="nx">dfs</span><span class="p">(</span><span class="nx">vertex</span><span class="p">.</span><span class="nx">neighbors</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">visited</span><span class="p">);</span> <span class="p">}</span> <span class="p">}</span> <span class="p">}</span> </code></pre></div></div> <p>In the above program, we first log the data contained in the vertex passed to the function <code class="language-plaintext highlighter-rouge">dfs</code>. Then, we run a <code class="language-plaintext highlighter-rouge">for-loop</code> to iterate through all the neighbours of that vertex. For each neighbour, we first check if it has already been visited. If not, we call the <code class="language-plaintext highlighter-rouge">dfs</code> function by passing that neighbour. The <code class="language-plaintext highlighter-rouge">for-loop</code> will terminate only after the <code class="language-plaintext highlighter-rouge">dfs</code> function is called for every un-visited vertex of the vertex that is passed to the function, during a given call.</p> <p>As graphs can be potentially cyclical, it is very important to ensure that a vertex that is already visited, is not visited again. As otherwise, the search may never complete. To this end, <code class="language-plaintext highlighter-rouge">Set</code> object is maintained, called <code class="language-plaintext highlighter-rouge">visited</code>, which stores all the vertices that have already been visited.</p> <p>In the case of binary search trees, we often implement <em>pre-order, in-order,</em> or <em>post-order</em> traversal. In each of these traversals, we visit the left sub-tree of a given node, before visiting its right-sub-tree. We do this recursively for each sub-tree within a tree. Thus, as we first go to a neighbour’s neighbours (or, in the case of trees, children’s children) before visiting the other neighbours (or children), each of these traversals are examples of depth-first search.</p> <h4 id="breadth-first-search">Breadth-first search</h4> <p>According to this method, we first visit all the immediate neighbours of a given vertex, before moving on to the neighbours’ neighbouring vertices. To implement a breadth-first search, we can visit each neighbour of a given vertex in any order. Once every neighbour is visited, we can start visiting each of the neighbours of the first neighbour that was visited, in the same manner. Breadth first search explores nodes nearer to the current node before exploring further. Hence it can be easily modeled by using a queue.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">bfs</span><span class="p">(</span><span class="nx">vertex</span><span class="p">)</span> <span class="p">{</span> <span class="kd">let</span> <span class="nx">q</span> <span class="o">=</span> <span class="p">[];</span> <span class="kd">let</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">();</span> <span class="nx">q</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">vertex</span><span class="p">);</span> <span class="k">while</span> <span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="kd">let</span> <span class="nx">deq</span> <span class="o">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">deq</span><span class="p">))</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">deq</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span> <span class="nx">visited</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">deq</span><span class="p">);</span> <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">deq</span><span class="p">.</span><span class="nx">neighbors</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="nx">q</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">deq</span><span class="p">.</span><span class="nx">neighbors</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="p">}</span> <span class="p">}</span> <span class="p">}</span> <span class="p">}</span> </code></pre></div></div> <p>In the above program, the array <code class="language-plaintext highlighter-rouge">q</code> is used to enqueue and dequeue each vertex and a <code class="language-plaintext highlighter-rouge">Set</code> object, <code class="language-plaintext highlighter-rouge">visited</code>, is used to store each vertex that has been visited once. Importantly, a neighbour of a particular vertex will be enqueued only if it has not been visited.</p> <p>In the context of binary search trees, <em>level-order traversals</em> follow a breadth-first search, as each node’s neighbours (or children) are visited first before visiting their neighbours (or children).</p> <h2 id="cloning-a-graph">Cloning a graph</h2> <p>If we need to clone an existing graph, we can use either of the two traversal methods, to visit every vertex of a given graph. To clone a graph, we will need to create identical copies of each vertices of the graph. Thus, each time we visit a vertex, we should create a new (cloned) vertex, and store the value and the neighbours of that vertex. In the following example, I use breadth-first search to clone a graph but it is equally possible to clone using depth-first search.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">cloneGraph</span><span class="p">(</span><span class="nx">vertex</span><span class="p">,</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">())</span> <span class="p">{</span> <span class="kd">let</span> <span class="nx">q</span> <span class="o">=</span> <span class="p">[];</span> <span class="kd">let</span> <span class="nx">deq</span><span class="p">;</span> <span class="kd">let</span> <span class="nx">clonedVertex</span><span class="p">;</span> <span class="nx">q</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">vertex</span><span class="p">);</span> <span class="k">while</span> <span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">length</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">deq</span> <span class="o">=</span> <span class="nx">q</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">visited</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">deq</span><span class="p">))</span> <span class="p">{</span> <span class="nx">clonedVertex</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Graph</span><span class="p">(</span><span class="nx">deq</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span> <span class="nx">clonedVertex</span><span class="p">.</span><span class="nx">neighbors</span> <span class="o">=</span> <span class="nx">deq</span><span class="p">.</span><span class="nx">neighbors</span><span class="p">;</span> <span class="nx">visited</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">deq</span><span class="p">);</span> <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">deq</span><span class="p">.</span><span class="nx">neighbors</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="nx">q</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">deq</span><span class="p">.</span><span class="nx">neighbors</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="p">}</span> <span class="p">}</span> <span class="p">}</span> <span class="k">return</span> <span class="nx">deq</span><span class="p">;</span> <span class="p">}</span> </code></pre></div></div></content>
<author>
<name/>
</author>
<category term="programming"/>
<summary type="html">A graph is an data structure consisting of a set of vertices, each of which are connected to one or more other vertices. In this post, I explore this data structure and implement some of its common operations.</summary>
</entry>
<entry>
<title type="html">Memoization by Way of Functional Programming</title>
<link href="https://otee.dev/2021/08/05/memoization.html" rel="alternate" type="text/html" title="Memoization by Way of Functional Programming"/>
<published>2021-08-05T00:00:00+00:00</published>
<updated>2021-08-05T00:00:00+00:00</updated>
<id>https://otee.dev/2021/08/05/memoization</id>
<content type="html" xml:base="https://otee.dev/2021/08/05/memoization.html"><p>In this post, I explore the concept of memoization and show how it can be a useful technique when dealing with computationally intensive functions that need to be called multiple times in a program.</p> <h2 id="what-is-memoization">What is Memoization?</h2> <p>It is an optimisation technique to store the return values of previous calls to the same function. This technique remembers previous values returned by building a dictionary of the values returned by a particular function each time it is called. When the same function is called with the same argument(s) more than once, the function simply relies on the dictionary (called a ‘memo’), and returns the corresponding value stored from the previous call, instead of executing the function for a second time. Memoization can be very useful when calling the same function multiple times slows down the program.</p> <h4 id="memoizing-a-one-argument-function">Memoizing a one-argument function</h4> <p>In the following example, the function <code class="language-plaintext highlighter-rouge">oneArg</code> accepts an integer as an argument and returns its squared value:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">oneArg</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">n</span><span class="p">;</span> <span class="p">}</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">oneArg</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span> <span class="c1">//4</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">oneArg</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span> <span class="c1">//4</span> </code></pre></div></div> <p>As shown above, each time we call the function <code class="language-plaintext highlighter-rouge">oneArg</code> it will execute the operation inside the function and return its value, irrespective of whether the same argument was passed to it at an earlier occasion.</p> <p>Here’s how we can memoize <code class="language-plaintext highlighter-rouge">oneArg</code> such that it does not execute the operation inside it, more than once for the same argument:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">memoizeOneArg</span><span class="p">()</span> <span class="p">{</span> <span class="kd">let</span> <span class="nx">memo</span> <span class="o">=</span> <span class="p">{};</span> <span class="c1">// to store the return values</span> <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span> <span class="kd">let</span> <span class="nx">strN</span> <span class="o">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span> <span class="k">if</span> <span class="p">(</span><span class="nx">memo</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">strN</span><span class="p">))</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">memo</span><span class="p">[</span><span class="nx">strN</span><span class="p">];</span> <span class="p">}</span> <span class="kd">let</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">oneArg</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span> <span class="nx">memo</span><span class="p">[</span><span class="nx">strN</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span> <span class="k">return</span> <span class="nx">temp</span><span class="p">;</span> <span class="p">};</span> <span class="p">}</span> <span class="kd">let</span> <span class="nx">memoizedOneArg</span> <span class="o">=</span> <span class="nx">memoizeOneArg</span><span class="p">();</span> </code></pre></div></div> <p>In the above example, we have written a new function called <code class="language-plaintext highlighter-rouge">memoizeOneArg</code>. This function initialises an object called <code class="language-plaintext highlighter-rouge">memo</code>, which will store each pair of arguments and their return values, as key-value pairs.</p> <p>Importantly, <code class="language-plaintext highlighter-rouge">memoizeOneArg</code> does not return the return value of <code class="language-plaintext highlighter-rouge">oneArg</code>. Instead, <strong>it returns another (anonymous) function.</strong> When this function is called, it will first check if the argument passed to it already exists as a property inside <code class="language-plaintext highlighter-rouge">memo</code>. If yes, the function will return the corresponding value of that property. Otherwise, it will call the actual function <code class="language-plaintext highlighter-rouge">oneArg</code>, store the return value inside <code class="language-plaintext highlighter-rouge">memo</code> and then, return that value to the caller.</p> <p>This round-about way of returning a new function which calls the original function <code class="language-plaintext highlighter-rouge">oneArg</code> is necessary because <strong>we want to initialise <code class="language-plaintext highlighter-rouge">memo</code> only once</strong>. We cannot initialise <code class="language-plaintext highlighter-rouge">memo</code> inside <code class="language-plaintext highlighter-rouge">oneArg</code> because each time that function is called, it will re-initialise <code class="language-plaintext highlighter-rouge">memo</code> as a new (and empty) object. So, <strong>we need a way to ensure that the object <code class="language-plaintext highlighter-rouge">memo</code> can retain the return values across multiple function calls</strong>. This can of course be achieved if we make <code class="language-plaintext highlighter-rouge">memo</code> a global object. But this is not advisable when dealing with complicated programs, as it often leads to conflicts with other local variables that may happen to the same name.</p> <p>So, we need a way to maintain a local variable, that can be accessed when we need to perform the operation done by the function <code class="language-plaintext highlighter-rouge">oneArg</code>. This can be done when we write a function (<code class="language-plaintext highlighter-rouge">memoizeOneArg</code>) that first initialises the object <code class="language-plaintext highlighter-rouge">memo</code> and then returns a function that checks <code class="language-plaintext highlighter-rouge">memo</code>’s properties before calling the actual function <code class="language-plaintext highlighter-rouge">oneArg</code>, in the manner explained above. Note that, the returned function will be initialised by a variable, and only this function should be called when the operation of <code class="language-plaintext highlighter-rouge">oneArg</code> needs to be executed. So, in the above example, the function <code class="language-plaintext highlighter-rouge">memoizedOneArg</code> should be called.</p> <p>To clearly prove that the above technique (of storing return values by calling a returned function) actually works, we can write a new function <code class="language-plaintext highlighter-rouge">oneArgRandom</code> which will always return a random value. By using memoization, we can ensure that the same values are returned against the same argument:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">oneArgRandom</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">+</span> <span class="nx">n</span><span class="p">;</span> <span class="p">}</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">oneArgRandom</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span> <span class="c1">// 2.39243349362445</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">oneArgRandom</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span> <span class="c1">//2.8532267954230015</span> <span class="kd">function</span> <span class="nx">memoizeOneArgRandom</span><span class="p">()</span> <span class="p">{</span> <span class="kd">let</span> <span class="nx">memo</span> <span class="o">=</span> <span class="p">{};</span> <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span> <span class="kd">let</span> <span class="nx">strN</span> <span class="o">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span> <span class="k">if</span> <span class="p">(</span><span class="nx">memo</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">strN</span><span class="p">))</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">memo</span><span class="p">[</span><span class="nx">strN</span><span class="p">];</span> <span class="p">}</span> <span class="kd">let</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">oneArgRandom</span><span class="p">(</span><span class="nx">n</span><span class="p">);</span> <span class="nx">memo</span><span class="p">[</span><span class="nx">strN</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span> <span class="k">return</span> <span class="nx">temp</span><span class="p">;</span> <span class="p">};</span> <span class="p">}</span> <span class="kd">let</span> <span class="nx">memoizedOneArgRandom</span> <span class="o">=</span> <span class="nx">memoizeOneArgRandom</span><span class="p">();</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">memoizedOneArgRandom</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span> <span class="c1">//2.2444724212882425</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">memoizedOneArgRandom</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span> <span class="c1">//2.2444724212882425</span> </code></pre></div></div> <p>However, in terms of use-case of memoization, it should only be used for pure functions, i.e., functions which will always return the same values for the same inputs, irrespective of the number of times it is called. <code class="language-plaintext highlighter-rouge">oneArgRandom</code> is not a pure function, as it is expected to return different values each time it is called. So, this function is not a fit-case for memoization; nevertheless, this example was used to show that our memoization technique is working.</p> <h4 id="memoizing-a-two-argument-function">Memoizing a two-argument function</h4> <p>The same technique can be used to memoize a two-argument function:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">twoArg</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">m</span><span class="p">;</span> <span class="p">}</span> <span class="kd">function</span> <span class="nx">memoizeTwoArg</span><span class="p">()</span> <span class="p">{</span> <span class="kd">let</span> <span class="nx">memo</span> <span class="o">=</span> <span class="p">{};</span> <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span> <span class="p">{</span> <span class="kd">let</span> <span class="nx">strNM</span> <span class="o">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span> <span class="o">+</span> <span class="nx">m</span><span class="p">.</span><span class="nx">toString</span><span class="p">();</span> <span class="k">if</span> <span class="p">(</span><span class="nx">memo</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">strNM</span><span class="p">))</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">memo</span><span class="p">[</span><span class="nx">strNM</span><span class="p">];</span> <span class="p">}</span> <span class="kd">let</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">twoArg</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="p">);</span> <span class="nx">memo</span><span class="p">[</span><span class="nx">strNM</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span> <span class="k">return</span> <span class="nx">temp</span><span class="p">;</span> <span class="p">};</span> <span class="p">}</span> <span class="kd">let</span> <span class="nx">memoizedTwoArg</span> <span class="o">=</span> <span class="nx">memoizeTwoArg</span><span class="p">();</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">memoizedTwoArg</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span> <span class="c1">//6</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">memoizedTwoArg</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span> <span class="c1">//6</span> </code></pre></div></div> <h4 id="memoizing-functions-with-n-arguments">Memoizing functions with n arguments</h4> <p>The memoizing function (namely, <code class="language-plaintext highlighter-rouge">memoizeOneArg</code> and <code class="language-plaintext highlighter-rouge">memoizeTwoArg</code> in the above examples) which returns the memoized version of another function, is, in fact, quite independent of the original function that is being memoized. In other words, the return value of the memoizing function is not dependent on the contents of the function being memoized, except for the number of parameters to be passed to it. This means that the <code class="language-plaintext highlighter-rouge">memoizeOneArg</code> and <code class="language-plaintext highlighter-rouge">memoizeTwoArg</code> would work just the same way for all one-argument functions and two-argument functions, respectively. We just have to replace the references to <code class="language-plaintext highlighter-rouge">oneArg</code> and <code class="language-plaintext highlighter-rouge">twoArg</code> with the names of the functions we want to memoise. Better still, we can pass the functions we want to memoize, as arguments to the memoizing function.</p> <p>We can also make one memoizing function that works with <em>any function</em>, irrespective of their requisite parameters, by using the spread syntax (<code class="language-plaintext highlighter-rouge">...</code>):</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">memoize</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span> <span class="kd">let</span> <span class="nx">memo</span> <span class="o">=</span> <span class="p">{};</span> <span class="k">return</span> <span class="kd">function</span> <span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span> <span class="kd">let</span> <span class="nx">strArgs</span> <span class="o">=</span> <span class="nx">args</span><span class="p">;</span> <span class="k">if</span> <span class="p">(</span><span class="nx">memo</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="nx">strArgs</span><span class="p">))</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">memo</span><span class="p">[</span><span class="nx">strArgs</span><span class="p">];</span> <span class="p">}</span> <span class="kd">let</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">f</span><span class="p">(...</span><span class="nx">args</span><span class="p">);</span> <span class="nx">memo</span><span class="p">[</span><span class="nx">strArgs</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span> <span class="k">return</span> <span class="nx">temp</span><span class="p">;</span> <span class="p">};</span> <span class="p">}</span> <span class="kd">let</span> <span class="nx">memoizedMultiply</span> <span class="o">=</span> <span class="nx">memoize</span><span class="p">((</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">m</span><span class="p">);</span> <span class="kd">let</span> <span class="nx">memoizedAverage</span> <span class="o">=</span> <span class="nx">memoize</span><span class="p">((</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">o</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">n</span> <span class="o">+</span> <span class="nx">m</span> <span class="o">+</span> <span class="nx">o</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">memoizedMultiply</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">));</span> <span class="c1">//6</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">memoizedAverage</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">));</span> <span class="c1">//5</span> </code></pre></div></div> <h4 id="what-about-recursive-functions">What about recursive functions?</h4> <p>Intuitively, memoization appears to be ideal when we have to work with recursive functions, as the chances of calling the same function with the same set of arguments multiple times, will be relatively high.</p> <p>However, <strong>if we simply pass a function which calls itself recursively, the benefit of memoization will be limited.</strong> This is because, once the passed function is called, the link with the memo object snaps and that function independently keeps calling itself without first checking if a return value for each such call already exists inside the memo.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">fibonacci</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">n</span><span class="p">;</span> <span class="p">}</span> <span class="k">return</span> <span class="nx">fibonacci</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">fibonacci</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span> <span class="p">}</span> <span class="kd">let</span> <span class="nx">memoizedFibo</span> <span class="o">=</span> <span class="nx">memoize</span><span class="p">(</span><span class="nx">fibonacci</span><span class="p">);</span> </code></pre></div></div> <p>In the above example, which returns the <em>n</em>th fibonacci value, the <code class="language-plaintext highlighter-rouge">memoizedFibo</code> will check the properties of <code class="language-plaintext highlighter-rouge">memo</code> only once: that is, when the <code class="language-plaintext highlighter-rouge">fibonacci</code> is being called with <code class="language-plaintext highlighter-rouge">n</code> as a parameter. But the return values of each recursive call happening inside <code class="language-plaintext highlighter-rouge">fibonacci</code> is neither being stored in <code class="language-plaintext highlighter-rouge">memo</code> nor is <code class="language-plaintext highlighter-rouge">memo</code> being checked before executing each recursive call. For example, if we pass <code class="language-plaintext highlighter-rouge">50</code> to <code class="language-plaintext highlighter-rouge">memoizedFibo</code>, it will first check whether <code class="language-plaintext highlighter-rouge">memo</code> contains <code class="language-plaintext highlighter-rouge">'50'</code> as a property. If not, it will directly call the passed function, <code class="language-plaintext highlighter-rouge">fibonacci</code>. Now, <code class="language-plaintext highlighter-rouge">fibonacci</code> will recursively call itself for all values from 0 till (n-1) multiple times, to arrive at the 50th fibonacci number. But the return values of these recursive calls will never be saved in the <code class="language-plaintext highlighter-rouge">memo</code>. (This is why, if we pass <code class="language-plaintext highlighter-rouge">50</code> to <code class="language-plaintext highlighter-rouge">memoizedFibo</code>, the function will not finish computing within a reasonable time-period, as the number of repeated recursive calls will be extremely high).</p> <p>To solve this, we need to ensure that during each recursive call, the function first checks the <code class="language-plaintext highlighter-rouge">memo</code> object. This is possible, if, <strong>instead of calling the original function, the function recursively calls the memoized version of itself</strong>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">memoizedFibo</span> <span class="o">=</span> <span class="nx">memoize</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">n</span><span class="p">;</span> <span class="p">}</span> <span class="k">return</span> <span class="nx">memoizedFibo</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">memoizedFibo</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span> <span class="p">});</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">memoizedFibo</span><span class="p">(</span><span class="mi">50</span><span class="p">));</span> <span class="c1">//output: 12586269025 [generated in 1.109 seconds]</span> </code></pre></div></div> <h2 id="takeaway">Takeaway</h2> <ul> <li> <p>Memoization is an efficient tool to save return values of functions, which can save time when the same function is expected to be called multiple times with the same set of arguments. However, memoization will work only with pure functions.</p> </li> <li> <p>Memoization is a <strong>practical use-case of functional programming:</strong> we are passing functions as arguments to another function, and we are setting functions as return values of other functions. Thus, memoization shows <a href="https://oitee.github.io/2021/07/11/higher-order-functions.html">how functions can be treated as first-class citizens in JavaScript.</a></p> </li> </ul></content>
<author>
<name/>
</author>
<category term="conceptual"/>
<summary type="html">In this post, I explore the concept of memoization and show how it can be a useful technique when dealing with computationally intensive functions that need to be called multiple times in a program.</summary>
</entry>
<entry>
<title type="html">Implementing Binary Search</title>
<link href="https://otee.dev/2021/08/04/binary-search.html" rel="alternate" type="text/html" title="Implementing Binary Search"/>
<published>2021-08-04T00:00:00+00:00</published>
<updated>2021-08-04T00:00:00+00:00</updated>
<id>https://otee.dev/2021/08/04/binary-search</id>
<content type="html" xml:base="https://otee.dev/2021/08/04/binary-search.html"><p>In this post, I write about how I solved a <a href="https://leetcode.com/problems/search-insert-position/">LeetCode problem</a> that required implementation of binary search in a sorted array.</p> <h2 id="the-problem">The problem</h2> <p>Given a sorted array <code class="language-plaintext highlighter-rouge">nums</code> containing integers and a <code class="language-plaintext highlighter-rouge">target</code> integer, return the index of the <code class="language-plaintext highlighter-rouge">target</code> in the array <code class="language-plaintext highlighter-rouge">nums</code>. If <code class="language-plaintext highlighter-rouge">target</code> is not part of the array, return the index in the array where <code class="language-plaintext highlighter-rouge">target</code> should be inserted.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Input: nums: [1, 3, 5, 7, 9] and target: 7 Output: 3 Input: nums: [1, 3, 5, 7, 9] and target: 6 Output: 3 Input:nums: [1, 3, 5, 7, 9] and target: 0 Output: 0 Input: nums: [1, 3, 5, 7, 9] and target: 7 Output: 5 </code></pre></div></div> <p><strong>However</strong>, the program should have a run-time complexity of <code class="language-plaintext highlighter-rouge">O(log n)</code>.</p> <h2 id="what-does-olog-n-mean">What does O(log n) mean?</h2> <p><code class="language-plaintext highlighter-rouge">O(log n)</code> refers to the Big-O notation. Simply put, the Big-O notation is used to loosely represent the relationship between the <em>size of the input</em> and the <em>amount of time an algorithm will take</em> to be executed. In other words, <em>“<a href="https://towardsdatascience.com/the-big-o-notation-d35d52f38134">How does the number of steps change as the input data elements increase?</a>”.</em></p> <p>Algorithms can have a simple and direct relationship with the input data-set: when the size of inputs increases by <em>n</em>, the number of operations increases by <em>n</em> (or, by <em>c*n</em>, where <em>c</em> is a constant). In other words, the computational time taken by such algorithms will grow proportionally to the size of the input. Such algorithms have a Big-O of n, represented as O(n).</p> <p>The number of operations to be executed in an algorithm can also be independent of the size of the input data-set (e.g. finding the <em>i</em>th element in an array). Such algorithms have O(1), i.e., the run-time of the algorithm will be constant, and not be dependent on the input-size. (As this post is not on Big-O notation, I will reserve the discussion on Big-O for another post).</p> <p>When an algorithm is said to have a O(log n), it means that the <em>rate at which</em> new operations (or steps) have to be carried out is a <em>fraction of the rate at which new inputs are added.</em> In other words, where, the input size increases by four times, but the number of additional operations only increases by two times, the algorithm will have a logarithmic time-complexity, or a O(log n).</p> <p>Contrast this with algorithms with O(n), where for each increment in the input size, there is an equivalent increase in the number of operations. Or, take the case of algorithms with exponential time-complexity, which have a multiplier effect (like the rate of spread of a viral pandemic), where for <em>n</em> new inputs, there are <em>c^n</em> new operations (where, <em>c</em> is a constant that is greater than 1). In other words, for every increment of the input size, there is a greater corresponding increase in the time-complexity of the algorithm. As we have seen in the case of the global pandemic, exponential functions <em>grow scarily fast</em>. Logarithmic functions, on the other hand, can be described as inverse-exponential functions: for every <em>n</em> new inputs, there are less than <em>n</em> new set of operations. Thus, logarithmic functions grow at a <em>very gradual pace</em>. To illustrate this, in the following graph, the <span style="color: blue;"> <strong>blue</strong> </span> curve represents an <strong>exponential</strong> function (y = 2^x), the <span style="color: green;"> <strong>green</strong> </span> curve represents a <strong>linear</strong> function (y = x) and the <span style="color: red;"> <strong>red</strong> </span> curve represents a <strong>logarithmic</strong> function (y = log<sub>2</sub> n).</p> <p><img src="/assets/images/exponential_linear_logarithmic.png" alt="Exponential, linear and logarithmic functions" /></p> <h2 id="relevance-of-olog-n-in-the-current-problem">Relevance of O(log n) in the current problem</h2> <p>It is quite simple to write a program to find whether a target value exists in an array and to return the correct index position of the target value, if it is not present in that array:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">searchAndInsert</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span> <span class="nx">insertIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">i</span><span class="p">;</span> <span class="p">}</span> <span class="k">if</span> <span class="p">(</span><span class="nx">target</span> <span class="o">&gt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">{</span> <span class="nx">insertIndex</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span> <span class="k">return</span> <span class="nx">insertIndex</span><span class="p">;</span> <span class="p">}</span> </code></pre></div></div> <p>However, this will have a time-complexity of O(n). Note that, the Big-O notation always depicts the worst-case scenario. Thus, in the above example, when the target is the last element in the array, the <code class="language-plaintext highlighter-rouge">for-loop</code> will run for the entire length of <code class="language-plaintext highlighter-rouge">num</code>. So, the number of operations is directly proportional to the input-size.</p> <p>To do the same task, but with significantly fewer operations in relation to the size of the input, we cannot simply iterate through the entire array and compare each element of the array with the target value. To carry out a search that has O(log n), we will need to implement a <em>binary search.</em></p> <h2 id="binary-search">Binary search</h2> <h4 id="what-is-it">What is it?</h4> <p>In a binary search, we start with the mid-point of the data-set (which is sorted in an ascending order). If the element in the middle of the data-set is the target value, we return the index of the middle element. Otherwise, we see if the target value is greater than or less than the value of the element in the middle. This will tell us in which half of the data-set, the target will lie. If the element in the middle of the data-set is <em>smaller</em> than the target, it means that target will be in the latter half (as all the elements from the 0th index till the mid-point will be smaller than the target). If the element in the middle of the data-set is <em>greater</em> than the target, it will mean that the target will be in the first-half of the data-set (i.e., between the 0th position and the mid-point).</p> <p>During each iteration of a binary search, we divide the data-set into two halves, and then divide one of the halves into two further halves. The selection of the halves are determined by comparing the element in the middle with the target. This continues, till we reach the target, or when we are left with an empty data-set.</p> <p>Here’s how to implement a binary search:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">binarySearch</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span> <span class="kd">let</span> <span class="nx">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="kd">let</span> <span class="nx">high</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="kd">let</span> <span class="nx">mid</span><span class="p">;</span> <span class="k">while</span> <span class="p">(</span><span class="nx">low</span> <span class="o">&lt;=</span> <span class="nx">high</span><span class="p">)</span> <span class="p">{</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">high</span> <span class="o">-</span> <span class="nx">low</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nx">low</span><span class="p">;</span> <span class="c1">//this gives us the mid-point element</span> <span class="k">if</span> <span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span> <span class="o">==</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">mid</span><span class="p">;</span> <span class="p">}</span> <span class="c1">//if target is greater than nums[mid], the next iteration should look at nums[mid + 1] to nums[high]</span> <span class="k">if</span><span class="p">(</span><span class="nx">target</span> <span class="o">&gt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="p">]){</span> <span class="nx">low</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span> <span class="c1">//if target is less than nums[mid], the next iteration should look at nums[low] to nums[mid - 1]</span> <span class="k">else</span><span class="p">{</span> <span class="nx">high</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// this will signify that the target is not present in the array nums</span> <span class="p">}</span> </code></pre></div></div> <p>In the above example, at each iteration of the <code class="language-plaintext highlighter-rouge">while-loop</code>, the mid-point element of the array is compared with <code class="language-plaintext highlighter-rouge">target</code>. If <code class="language-plaintext highlighter-rouge">target == nums[mid]</code>, <code class="language-plaintext highlighter-rouge">mid</code> will be returned. Otherwise, <code class="language-plaintext highlighter-rouge">target</code> will be compared with <code class="language-plaintext highlighter-rouge">nums[mid]</code>, as shown above.</p> <p>There are two important points to note:</p> <ul> <li> <p><em>How should values of <code class="language-plaintext highlighter-rouge">low</code> and <code class="language-plaintext highlighter-rouge">high</code> be changed during each iteration?</em> Once we know that <code class="language-plaintext highlighter-rouge">nums[mid]</code> is not the target, we need not include that specific element in the next iteration. For this reason, we define <code class="language-plaintext highlighter-rouge">low = mid + 1</code> when target is greater than <code class="language-plaintext highlighter-rouge">nums[mid]</code>. This is because, <strong>when <code class="language-plaintext highlighter-rouge">target &gt; nums[mid]</code> it follows that every element in the array upto and including the element at the <code class="language-plaintext highlighter-rouge">mid</code> index, are less than the <code class="language-plaintext highlighter-rouge">target</code></strong> and therefore, cannot contain the <code class="language-plaintext highlighter-rouge">target</code>. Conversely, we define <code class="language-plaintext highlighter-rouge">high = mid - 1</code> when the target is less than <code class="language-plaintext highlighter-rouge">nums[mid]</code>, because when <code class="language-plaintext highlighter-rouge">**target &lt; nums[mid]</code> is less than <code class="language-plaintext highlighter-rouge">nums[mid]</code>, it follows that every element starting with the element at <code class="language-plaintext highlighter-rouge">mid</code> and thereafter are greater than the <code class="language-plaintext highlighter-rouge">target</code> and therefore they cannot contain <code class="language-plaintext highlighter-rouge">target</code>**.</p> </li> <li> <p><em>When should the loop terminate?</em> The <code class="language-plaintext highlighter-rouge">while-loop</code> should terminate when we are left with no more elements to look at. This is important because <strong>it can very well be the case that <code class="language-plaintext highlighter-rouge">target</code> is not present in <code class="language-plaintext highlighter-rouge">nums</code></strong>. In the above example, we achieve this, by keeping the condition for the <code class="language-plaintext highlighter-rouge">while-loop</code> as <code class="language-plaintext highlighter-rouge">low &lt;= high</code>. In a case where <code class="language-plaintext highlighter-rouge">target</code> is not present in <code class="language-plaintext highlighter-rouge">nums</code>, we will reach a point where both <code class="language-plaintext highlighter-rouge">low</code> and <code class="language-plaintext highlighter-rouge">high</code> are pointing to the same element in the array. At this point, the following will be true <code class="language-plaintext highlighter-rouge">mid==low==high</code>. Now, either the <code class="language-plaintext highlighter-rouge">target</code> will be less or greater than the element at the current <code class="language-plaintext highlighter-rouge">mid</code> index. If its the former, <code class="language-plaintext highlighter-rouge">high</code> will be decreased by 1. If its the latter, <code class="language-plaintext highlighter-rouge">low</code> will be increased by 1. In either case, it will break the condition of the <code class="language-plaintext highlighter-rouge">while-loop</code> as <code class="language-plaintext highlighter-rouge">high</code> will now be less than <code class="language-plaintext highlighter-rouge">low</code>.</p> </li> </ul> <h4 id="does-binary-search-have-an-olog-n">Does binary search have an O(log n)?</h4> <p>While running a binary search, at each iteration, the size of the data-set shrinks by half. Assuming the worst-case scenario (i.e., when the target value is in at the index when <code class="language-plaintext highlighter-rouge">low==high</code> is true, i.e., when the data-set will be containing only one element), the number of elements remaining to be checked changes (at each iteration) as shown below:</p> <p><img src="/assets/images/binarysearch_1.jpg" alt="n —&gt; n/2 —&gt; n/8—&gt; n/16...n/n" /></p> <p>First, we have n elements to check, then by looking at the middle element of the sorted array, we throw away half the array. Now, in the selected half, we have n/2 elements, which again is halved. This continues until we have only one element remaining to be checked.</p> <p>The above expression can be expressed in the following manner as well:</p> <p><img src="/assets/images/binarysearch_2.jpg" alt="n —&gt; n/2^1 —&gt; n/2^2 —&gt; n/2^3.... n/2^x" /></p> <p>Thus, in the worst-case scenario, the total number of operations will be x:</p> <p><img src="/assets/images/binarysearch_3.jpg" alt="n/2^x = 1; or n= 2^x" /></p> <p>By definition, this can be expressed as:</p> <p><img src="/assets/images/binarysearch_4.jpg" alt="x = log2 n" /></p> <p>Since <em>x</em> represents the number of operations, the Big-O of a binary search would be: O(log n). Thus, if there were 1024 elements in an array, a linear search would require (at-most) 1024 operations to find a specific element. A binary search, on the other hand, would require only 10 steps (as log<sub>2</sub> 1024 = 10).</p> <h2 id="implementing-binary-search-and-replace">Implementing binary search and replace</h2> <p>The above program will not return the correct index of <code class="language-plaintext highlighter-rouge">target</code> if it is not present in the array (It will simply return <code class="language-plaintext highlighter-rouge">-1</code> if <code class="language-plaintext highlighter-rouge">target</code> is not present in <code class="language-plaintext highlighter-rouge">nums</code>].</p> <p>But the <a href="https://leetcode.com/problems/search-insert-position/">LeetCode problem</a> at hand also requires us to accurately return the index where <code class="language-plaintext highlighter-rouge">target</code> should be inserted in the array <code class="language-plaintext highlighter-rouge">nums</code>, if it is not present already.</p> <p>In the example above, when we reach the last round of the <code class="language-plaintext highlighter-rouge">while-loop</code>, when <code class="language-plaintext highlighter-rouge">low==high</code> is true, the index represented by <code class="language-plaintext highlighter-rouge">low</code> and <code class="language-plaintext highlighter-rouge">high</code> indicate the index that is <em>nearest</em> to where <code class="language-plaintext highlighter-rouge">target</code> should be present in the array.</p> <p>Now, <code class="language-plaintext highlighter-rouge">target</code> can either be greater or less than the element at the <code class="language-plaintext highlighter-rouge">mid</code>/ <code class="language-plaintext highlighter-rouge">low</code> / <code class="language-plaintext highlighter-rouge">high</code> index of the array. If <code class="language-plaintext highlighter-rouge">target &lt; nums[mid]</code>, <code class="language-plaintext highlighter-rouge">target</code> should be inserted at the <code class="language-plaintext highlighter-rouge">mid</code> index and the element on that index should be shifted to the next index. Conversely, if <code class="language-plaintext highlighter-rouge">target &gt; nums[mid]</code>, <code class="language-plaintext highlighter-rouge">target</code> should be inserted in the index right after <code class="language-plaintext highlighter-rouge">mid</code>. Given this, <strong>the value of <code class="language-plaintext highlighter-rouge">low</code> would represent the index where <code class="language-plaintext highlighter-rouge">target</code> should be inserted</strong>: this is because, the value of <code class="language-plaintext highlighter-rouge">low</code> (which is the same value as <code class="language-plaintext highlighter-rouge">mid</code> in the last round of iteration), increases by 1 when <code class="language-plaintext highlighter-rouge">target</code> is greater than <code class="language-plaintext highlighter-rouge">nums[mid]</code> and the value of <code class="language-plaintext highlighter-rouge">low</code> remains unchanged (i.e., same as that of <code class="language-plaintext highlighter-rouge">mid</code>) when <code class="language-plaintext highlighter-rouge">target</code> is less than <code class="language-plaintext highlighter-rouge">nums[mid]</code></p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">binarySearch</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span> <span class="kd">let</span> <span class="nx">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="kd">let</span> <span class="nx">high</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="kd">let</span> <span class="nx">mid</span><span class="p">;</span> <span class="k">while</span> <span class="p">(</span><span class="nx">low</span> <span class="o">&lt;=</span> <span class="nx">high</span><span class="p">)</span> <span class="p">{</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">((</span><span class="nx">high</span> <span class="o">-</span> <span class="nx">low</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nx">low</span><span class="p">;</span> <span class="c1">//this gives us the mid-point element</span> <span class="k">if</span> <span class="p">(</span><span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span> <span class="o">==</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">mid</span><span class="p">;</span> <span class="p">}</span> <span class="k">if</span><span class="p">(</span><span class="nx">target</span> <span class="o">&gt;</span> <span class="nx">nums</span><span class="p">[</span><span class="nx">mid</span><span class="p">]){</span> <span class="nx">low</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span> <span class="k">else</span><span class="p">{</span> <span class="nx">high</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span> <span class="k">return</span> <span class="nx">low</span><span class="p">;</span> <span class="p">}</span> </code></pre></div></div></content>
<author>
<name/>
</author>
<category term="programming"/>
<summary type="html">In this post, I write about how I solved a LeetCode problem that required implementation of binary search in a sorted array.</summary>
</entry>
<entry>
<title type="html">Implementing Stacks</title>
<link href="https://otee.dev/2021/07/30/implementing-stacks.html" rel="alternate" type="text/html" title="Implementing Stacks"/>
<published>2021-07-30T00:00:00+00:00</published>
<updated>2021-07-30T00:00:00+00:00</updated>
<id>https://otee.dev/2021/07/30/implementing-stacks</id>
<content type="html" xml:base="https://otee.dev/2021/07/30/implementing-stacks.html"><p>Stack is a common data structure that is often used to retrieve and insert data items in a specific order. In this post, I will implement some of the common operations involving stacks.</p> <h2 id="what-are-stacks">What are stacks?</h2> <p>Stacks are data-structures, where the data items are arranged and retrieved as per the last-in-first-out (LIFO) order. <strong>This means that the last item added to the data structure will be the first item that can be accessed.</strong> This kind of data structure is modelled after a real-world <em>stack</em> of plates in a kitchen sink. It can also be thought of as a jar of biscuits, where one can only reach the first item before moving onto the next one.</p> <p>LIFO has many practical applications. For example, <strong>the undo-operation (ctrl + z) that is available in various computer programs, follow the LIFO principle</strong>, as we always need to access the last change carried out. <a href="/2021/07/25/valid-parenthesis.html">Brackets are opened and closed</a> as per this order as well.</p> <p>Also, function calls are internally maintained as a stack by the computer. If we have three functions f, g and h and they are interwoven in their calls, i.e., f(g(h(x, y))), then the function f cannot be called until the function g has finished and returned, which cannot be called until h has finished and returned. Function h is the last function that was called and is the first that must be finished.</p> <h4 id="common-operations">Common operations</h4> <p>Some of the common operations involving stack are as follows:</p> <p><code class="language-plaintext highlighter-rouge">isEmpty()</code>: returns <code class="language-plaintext highlighter-rouge">true</code> if a stack is empty, i.e., if it does not contain any data items.</p> <p><code class="language-plaintext highlighter-rouge">push()</code>: adds a new item at the top of the stack.</p> <p><code class="language-plaintext highlighter-rouge">pop()</code>: deletes the last added item from a stack and returns the deleted item</p> <p><code class="language-plaintext highlighter-rouge">peek()</code>: returns the last added item from a stack.</p> <p><img src="/assets/images/stackPushPop.jpg" alt="pop and push operations" /></p> <h2 id="implementation">Implementation</h2> <p>To create a stack, we need to first write an appropriate constructor function. Much like how linked lists are created, each new stack data structure can be created by invoking this constructor function along with the <code class="language-plaintext highlighter-rouge">new</code> function.</p> <h3 id="designing-the-constructor-function">Designing the constructor function</h3> <p>The constructor function will essentially create objects carrying certain common properties. Recall that, the <a href="/2021/07/19/creating-objects-in-javascript.html">concept of class-based objects</a> can be incorporated in JavaScript, by using constructor functions, which can set the common properties which each object will possess.</p> <p>Now, we know that we need to be able to insert and delete items as per the LIFO order. To do this, we will need to write functions that can carry out the aforesaid <code class="language-plaintext highlighter-rouge">push</code> and <code class="language-plaintext highlighter-rouge">pop</code> operations effectively. As these functions will be integral to this data structure, they will need to be available to every object created by the constructor function. Thus, the constructor will create these functions as properties for each object it creates. When functions sit inside an object (as properties of that object), they are called ‘methods’.</p> <p>Apart from creating methods, the constructor will also need to provide a space to store the data items, which the requisite methods can access. To this end, we can either rely on arrays or linked lists.</p> <p>Thus, from the above discussion, it is clear that to implement a stack data structure, we need to write a constructor function, which will have two components: a) a set of methods, that carry out the requisite operations associated with stacks, and b) a container for holding the data items to be stored inside a stack.</p> <p>Thus, the constructor function, that relies on linked lists, would look something like this:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Stack</span><span class="p">(){</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span><span class="c1">//for storing the latest inserted node in the list</span> <span class="k">this</span><span class="p">.</span><span class="nx">Node</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">{...};</span><span class="c1">// for creating the linked list to store the data-items</span> <span class="k">this</span><span class="p">.</span><span class="nx">isEmpty</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">{...};</span> <span class="k">this</span><span class="p">.</span><span class="nx">pop</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){...};</span> <span class="k">this</span><span class="p">.</span><span class="nx">push</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">){...};</span> <span class="k">this</span><span class="p">.</span><span class="nx">peek</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">{...};</span> <span class="p">}</span> <span class="kd">let</span> <span class="nx">newStack</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Stack</span><span class="p">();</span><span class="c1">// creates a new stack data structure by invoking Stack()</span> </code></pre></div></div> <p>Similarly, the constructor function, that relies on arrays, will look something like this:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Stack</span><span class="p">(){</span> <span class="k">this</span><span class="p">.</span><span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span><span class="c1">//for storing the data items</span> <span class="k">this</span><span class="p">.</span><span class="nx">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">//for storing the index of the top-most item</span> <span class="k">this</span><span class="p">.</span><span class="nx">isEmpty</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{...};</span> <span class="k">this</span><span class="p">.</span><span class="nx">pop</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){...};</span> <span class="k">this</span><span class="p">.</span><span class="nx">push</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">){...};</span> <span class="k">this</span><span class="p">.</span><span class="nx">peek</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){...};</span> <span class="p">}</span> <span class="kd">let</span> <span class="nx">newStackUsingArray</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">StackUsingArray</span><span class="p">();</span> </code></pre></div></div> <p>In the following part of this post, I will show how each of these methods will be written. (To see how a constructor function for linked lists is written, please see <a href="/2021/07/28/linked-lists-in-javascript.html">my earlier post on this topic</a>.)</p> <h3 id="isempty">isEmpty()</h3> <p>The task of this method is to determine if a stack object (created by the constructor) is holding any data item presently. This method would not only be useful to the user working with stacks, but will also be relied upon by the other methods inside the stack object (as shown below). If a stack is empty, this method should return <code class="language-plaintext highlighter-rouge">true</code>. Else, it will return <code class="language-plaintext highlighter-rouge">false</code>.</p> <p><em>For stacks built using linked lists:</em></p> <p>We need to see if the <code class="language-plaintext highlighter-rouge">this.head</code> item is <code class="language-plaintext highlighter-rouge">undefined</code>. If yes, it would indicate either that no node has yet been created, or that every node that was created has since been popped out of the stack.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nx">isEmpty</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span> <span class="o">==</span> <span class="kc">undefined</span><span class="p">;</span> <span class="p">};</span> </code></pre></div></div> <p><em>For stacks built using arrays:</em></p> <p>In this case, a stack would be considered empty, if the value stored inside <code class="language-plaintext highlighter-rouge">this.index</code> is less than 0. The initial value of <code class="language-plaintext highlighter-rouge">this.index</code> will always be -1. With each item being pushed into the stack, the value of <code class="language-plaintext highlighter-rouge">this.index</code> will be increased by one. Conversely, with each item being popped out of the stack, the value of <code class="language-plaintext highlighter-rouge">this.index</code> will be reduced by one. Thus, when the value of <code class="language-plaintext highlighter-rouge">this.index</code> goes below 0, it will indicate either that no item has been pushed into the stack, or that every item that was pushed into the stack had been popped out.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nx">isEmpty</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> </code></pre></div></div> <h3 id="push">push()</h3> <p>This method will accept a data item as an argument and will push that item into the stack. The newly pushed item will now be the top-most item. So, the value of <code class="language-plaintext highlighter-rouge">this.head</code> (in the case of linked lists) or the value of <code class="language-plaintext highlighter-rouge">this.index</code> (in the case of arrays) will need to be changed accordingly, with each invocation of this method. Finally, this method should return the value of the item that has been pushed into the stack.</p> <p><em>For stacks built using linked lists:</em></p> <p>When a new item is to be pushed, a new node (carrying that item) should be inserted into the linked list. As shown in <a href="/2021/07/28/linked-lists-in-javascript.html">my earlier post</a>, the new node can be inserted at the head of the linked list.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nx">push</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">isEmpty</span><span class="p">())</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span> <span class="o">=</span> <span class="k">new</span> <span class="k">this</span><span class="p">.</span><span class="nx">Node</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span> <span class="p">}</span> <span class="kd">let</span> <span class="nx">pushedNode</span> <span class="o">=</span> <span class="k">new</span> <span class="k">this</span><span class="p">.</span><span class="nx">Node</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="nx">pushedNode</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span> <span class="o">=</span> <span class="nx">pushedNode</span><span class="p">;</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span> <span class="p">};</span> </code></pre></div></div> <p><em>For stacks built using arrays:</em></p> <p>In this case, we need to insert the new item at <code class="language-plaintext highlighter-rouge">this.index +1</code> of <code class="language-plaintext highlighter-rouge">this.arr</code>, i.e., the index right after the index of the last inserted item. Note that, while working with some programming languages such as C and Java, where arrays are of fixed capacity, we should first check if adding a new item to the array would exceed the capacity that was initially allocated for that array. However, this is not necessary in JavaScript, as arrays are always dynamically resized.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nx">push</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="nx">index</span><span class="o">++</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">index</span><span class="p">]</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span> <span class="k">return</span> <span class="nx">x</span><span class="p">;</span> <span class="p">};</span> </code></pre></div></div> <h3 id="pop">pop()</h3> <p>This method will delete the last item that was pushed into the stack and return that item to the caller. However, before carrying out this operation, it would be important to see if the stack is empty. This can be done by invoking the <code class="language-plaintext highlighter-rouge">this.isEmpty()</code> method. If the stack is empty, an appropriate error message should be returned.</p> <p><em>For stacks built using linked lists:</em></p> <p>If the stack is not empty, the node next to the head node should be replaced as the new head node of the linked list, i.e., <code class="language-plaintext highlighter-rouge">this.head = this.head.next</code>. But before carrying out this change, it would be important to store the data carried by <code class="language-plaintext highlighter-rouge">this.head</code>, as we will need to return that value:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nx">pop</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">isEmpty</span><span class="p">())</span> <span class="p">{</span> <span class="k">return</span> <span class="dl">"</span><span class="s2">stack underflow</span><span class="dl">"</span><span class="p">;</span> <span class="p">}</span> <span class="kd">let</span> <span class="nx">popped</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span> <span class="k">return</span> <span class="nx">popped</span><span class="p">;</span> <span class="p">};</span> </code></pre></div></div> <p><em>For stacks built using arrays:</em></p> <p>For stacks using arrays, we need to return the data item at the <code class="language-plaintext highlighter-rouge">this.index</code> of <code class="language-plaintext highlighter-rouge">this.arr</code> and reduce the value <code class="language-plaintext highlighter-rouge">this.index</code> by one.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nx">pop</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">isEmpty</span><span class="p">())</span> <span class="p">{</span> <span class="k">return</span> <span class="dl">"</span><span class="s2">stack underflow</span><span class="dl">"</span><span class="p">;</span> <span class="p">}</span> <span class="kd">let</span> <span class="nx">popped</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">index</span><span class="p">];</span> <span class="k">this</span><span class="p">.</span><span class="nx">index</span><span class="o">--</span><span class="p">;</span> <span class="k">return</span> <span class="nx">popped</span><span class="p">;</span> <span class="p">};</span> </code></pre></div></div> <h3 id="peek">peek()</h3> <p>This method will return the last item that was pushed to a stack.</p> <p><em>For stacks built using linked lists:</em></p> <p>For stacks using linked lists, we need to return the value stored in <code class="language-plaintext highlighter-rouge">this.head.data</code>. But before doing this, we need to first check if the stack is empty.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nx">peek</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">isEmpty</span><span class="p">())</span> <span class="p">{</span> <span class="k">return</span> <span class="dl">"</span><span class="s2">stack empty</span><span class="dl">"</span><span class="p">;</span> <span class="p">}</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span> <span class="p">};</span> </code></pre></div></div> <p><em>For stacks built using arrays</em>:</p> <p>We need to return the value stored at <code class="language-plaintext highlighter-rouge">this.index</code> of <code class="language-plaintext highlighter-rouge">this.arr</code> of the stack. But, if the stack is empty, we need to return an appropriate response.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nx">peek</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">isEmpty</span><span class="p">())</span> <span class="p">{</span> <span class="k">return</span> <span class="dl">"</span><span class="s2">stack empty</span><span class="dl">"</span><span class="p">;</span> <span class="p">}</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">arr</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">index</span><span class="p">];</span> <span class="p">};</span> </code></pre></div></div></content>
<author>
<name/>
</author>
<category term="programming"/>
<summary type="html">Stack is a common data structure that is often used to retrieve and insert data items in a specific order. In this post, I will implement some of the common operations involving stacks.</summary>
</entry>
<entry>
<title type="html">Implementing Linked Lists</title>
<link href="https://otee.dev/2021/07/28/linked-lists-in-javascript.html" rel="alternate" type="text/html" title="Implementing Linked Lists"/>
<published>2021-07-28T00:00:00+00:00</published>
<updated>2021-07-28T00:00:00+00:00</updated>
<id>https://otee.dev/2021/07/28/linked-lists-in-javascript</id>
<content type="html" xml:base="https://otee.dev/2021/07/28/linked-lists-in-javascript.html"><p>In the <a href="/2021/07/27/data-structures-arrays-and-linked-lists.html">previous post</a>, I wrote about the concept of linked lists and how they are different from arrays. In this post, I write about some of the basic operations that can be carried out on a linked list.</p> <h2 id="creating-a-linked-list">Creating a linked list</h2> <p>To create a linked list, we need to first write a constructor function that will create each node of the list. Typically, a node will be a JavaScript object created by the constructor function. The constructor will accept one or more values as arguments for storing them as properties in each node object. The constructor will also create one or more properties that will act as pointers to one or more nodes in the list.</p> <p>In the example below, the constructor function <code class="language-plaintext highlighter-rouge">Node</code> will assign two properties to each node it creates, namely: <code class="language-plaintext highlighter-rouge">this.data</code>, which will store the value passed to <code class="language-plaintext highlighter-rouge">Node</code> constructor, and <code class="language-plaintext highlighter-rouge">this.next</code> which will contain the link to the next object in this list. <code class="language-plaintext highlighter-rouge">this.next</code> will be initially be assigned to <code class="language-plaintext highlighter-rouge">null</code>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span> <span class="k">this</span><span class="p">.</span><span class="nx">data</span> <span class="o">=</span> <span class="nx">data</span><span class="p">;</span> <span class="k">this</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="p">}</span> </code></pre></div></div> <p>When a new node is created by the constructor function, its <code class="language-plaintext highlighter-rouge">next</code> property will point to <code class="language-plaintext highlighter-rouge">null</code>. So, each time a subsequent node is created within a linked list, it is important to link the <code class="language-plaintext highlighter-rouge">next</code> property of the previous node to that new node.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span><span class="c1">//head node</span> <span class="nx">head</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span><span class="c1">// second node</span> <span class="nx">head</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span><span class="c1">// third node</span> <span class="nx">head</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span><span class="c1">// fourth node</span> </code></pre></div></div> <h2 id="constructing-a-linked-list-from-an-array">Constructing a linked list from an array</h2> <p>While it is possible to create new nodes by manually linking them to the previous node’s <code class="language-plaintext highlighter-rouge">.next</code> property, it is also possible to do this iteratively. For example, given an array, it is possible to create a linked list using a <code class="language-plaintext highlighter-rouge">for loop</code> and a temporary variable (say <code class="language-plaintext highlighter-rouge">tail</code>). During each iteration of the loop, <code class="language-plaintext highlighter-rouge">tail</code> can be used to point to the last node that was created in the linked list, and <code class="language-plaintext highlighter-rouge">tail.next</code> can be used to create the next new node in the list. Once the new node is created, <code class="language-plaintext highlighter-rouge">tail</code> should point to that node: <code class="language-plaintext highlighter-rouge">tail = tail.next</code>. This will be repeated for each element of the array. However, it is important to store the location of the first node, as a linked list is identified by its head node. Thus, we must create the head node outside the loop, and assign it to the <code class="language-plaintext highlighter-rouge">tail</code> variable, which can, then, be used to create the subsequent nodes in the list.</p> <p>Note that, we can use loops to change the <code class="language-plaintext highlighter-rouge">.next</code> properties of every node (which is, in fact, an object) by using the same variable (<code class="language-plaintext highlighter-rouge">tail</code>, in this example) because variables <a href="/2021/07/09/understanding-const.html">are just names or identifiers to actual objects</a>. Multiple variables can ‘point’ or ‘refer’ to the same object and each of them can be used to modify the properties of the object. Hence, we can use any variable (such as <code class="language-plaintext highlighter-rouge">tail</code>), to change multiple nodes in a linked list.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">arrayToLinkedList</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span> <span class="kd">let</span> <span class="nx">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="kd">let</span> <span class="nx">tail</span> <span class="o">=</span> <span class="nx">head</span><span class="p">;</span> <span class="c1">//creating the linked list iteratively</span> <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="nx">tail</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span> <span class="nx">tail</span> <span class="o">=</span> <span class="nx">tail</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span> <span class="p">}</span> <span class="k">return</span> <span class="nx">head</span><span class="p">;</span> <span class="p">}</span> </code></pre></div></div> <h2 id="searching-through-a-linked-list">Searching through a linked list</h2> <p>Given a linked list, it is possible to traverse through the entire list to find out if a particular data exists within that list. In the following example, the function <code class="language-plaintext highlighter-rouge">search</code> accepts two arguments: the head node of a linked list(<code class="language-plaintext highlighter-rouge">list</code>), and the value of to be searched for(<code class="language-plaintext highlighter-rouge">x</code>):</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">search</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">while</span> <span class="p">(</span><span class="nx">list</span> <span class="o">!=</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">data</span> <span class="o">==</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">list</span><span class="p">;</span> <span class="p">}</span> <span class="nx">list</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span> <span class="p">}</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span> <span class="c1">//calling search by passing the head node of the linked list created in the first example</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">search</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="mi">9</span><span class="p">));</span> <span class="c1">//Node { data: 9, next: Node { data: 10, next: null } }</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">search</span><span class="p">(</span><span class="nx">head</span><span class="p">,</span> <span class="mi">11</span><span class="p">));</span> <span class="c1">// undefined</span> </code></pre></div></div> <h2 id="inserting-a-new-node">Inserting a new node</h2> <p>As discussed in the <a href="/2021/07/27/data-structures-arrays-and-linked-lists.html">previous post</a>, we can simply add a new node at the beginning of the linked list:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">insertAnyWhere</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">data</span><span class="p">){</span> <span class="kd">let</span> <span class="nx">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">data</span><span class="p">);</span> <span class="nx">newNode</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">list</span><span class="p">;</span> <span class="k">return</span> <span class="nx">newNode</span><span class="p">;</span> <span class="p">}</span> </code></pre></div></div> <p>In the above example, the <code class="language-plaintext highlighter-rouge">newNode</code> points to the new node carrying <code class="language-plaintext highlighter-rouge">data</code>. The <code class="language-plaintext highlighter-rouge">.next</code> property of <code class="language-plaintext highlighter-rouge">newNode</code> points to <code class="language-plaintext highlighter-rouge">list</code> which is the original head node of the linked list. Finally, <code class="language-plaintext highlighter-rouge">insertAnywhere</code> returns <code class="language-plaintext highlighter-rouge">newNode</code> to signal to the caller that this is the new head of the linked list.</p> <p>It is also possible to insert a new node at a specific location within a linked list. In the following example, the function <code class="language-plaintext highlighter-rouge">insertAfter</code> accepts three parameters: <code class="language-plaintext highlighter-rouge">list</code>, <code class="language-plaintext highlighter-rouge">data</code> and <code class="language-plaintext highlighter-rouge">newData</code>. It adds a new node carrying <code class="language-plaintext highlighter-rouge">newData</code> in <code class="language-plaintext highlighter-rouge">list</code>, after the node that carries <code class="language-plaintext highlighter-rouge">data</code>:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">insertAfter</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">newData</span><span class="p">)</span> <span class="p">{</span> <span class="kd">let</span> <span class="nx">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">newData</span><span class="p">);</span> <span class="c1">//calling the search function, to find out the node carrying 'data'</span> <span class="kd">let</span> <span class="nx">targetNode</span> <span class="o">=</span> <span class="nx">search</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">data</span><span class="p">);</span> <span class="c1">// returning an appropriate message if 'data' does not exist within 'list'</span> <span class="k">if</span> <span class="p">(</span><span class="nx">targetNode</span> <span class="o">==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">data</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">does not exist</span><span class="dl">"</span><span class="p">;</span> <span class="p">}</span> <span class="c1">//checking if the head node is the targetNode</span> <span class="c1">//if yes, we will need to change the head node</span> <span class="k">if</span> <span class="p">(</span><span class="nx">targetNode</span> <span class="o">==</span> <span class="nx">list</span><span class="p">)</span> <span class="p">{</span> <span class="nx">newNode</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">list</span><span class="p">;</span> <span class="k">return</span> <span class="nx">newNode</span><span class="p">;</span> <span class="p">}</span> <span class="c1">//if the targetNode is any other node in the list</span> <span class="c1">//newNode should point to the node after targetNode</span> <span class="c1">//and targetNode should point to newNode</span> <span class="nx">newNode</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">targetNode</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span> <span class="nx">targetNode</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">newNode</span><span class="p">;</span> <span class="k">return</span> <span class="nx">list</span><span class="p">;</span> <span class="p">}</span> </code></pre></div></div> <p>Similarly, it is possible to insert an element before a specific node in a linked list. For this, we cannot rely on the <code class="language-plaintext highlighter-rouge">search</code> function, as we need to know the location of node prior to the target node. Thus, we can create a new function <code class="language-plaintext highlighter-rouge">searchPreviousNode</code> that returns the node immediately prior to a specific node in a linked list:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">searchPreviousNode</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//checking if list exists</span> <span class="c1">// and if list points to the last node of the list</span> <span class="k">if</span> <span class="p">(</span><span class="nx">list</span> <span class="o">==</span> <span class="kc">undefined</span> <span class="o">||</span> <span class="nx">list</span><span class="p">.</span><span class="nx">next</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span> <span class="c1">//loop to find out the node which points to the node that carries x</span> <span class="k">while</span> <span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">data</span> <span class="o">==</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">list</span><span class="p">;</span> <span class="p">}</span> <span class="nx">list</span> <span class="o">=</span> <span class="nx">list</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span> <span class="p">}</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span> </code></pre></div></div> <p>Now, we can use <code class="language-plaintext highlighter-rouge">searchPreviousNode</code> to insert a new node immediately prior to a given node:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">insertBefore</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">newData</span><span class="p">)</span> <span class="p">{</span> <span class="kd">let</span> <span class="nx">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Node</span><span class="p">(</span><span class="nx">newData</span><span class="p">);</span> <span class="c1">//checking if the head node contains 'data'</span> <span class="k">if</span> <span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">data</span> <span class="o">==</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span> <span class="nx">newNode</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">list</span><span class="p">;</span> <span class="k">return</span> <span class="nx">newNode</span><span class="p">;</span> <span class="p">}</span> <span class="c1">//calling searchPreviousNode(), to find the (n-1)th node </span> <span class="kd">let</span> <span class="nx">previous</span> <span class="o">=</span> <span class="nx">searchPreviousNode</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">data</span><span class="p">);</span> <span class="c1">//checking to see if 'previous' is undefined</span> <span class="k">if</span> <span class="p">(</span><span class="nx">previous</span> <span class="o">==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">data</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">does not exist</span><span class="dl">"</span><span class="p">;</span> <span class="p">}</span> <span class="c1">//if 'previous' is a node other than the head node, </span> <span class="c1">//the 'newNode' should point to the node after 'previous' node'</span> <span class="c1">//and the 'previous' should point to the 'newNode' </span> <span class="nx">newNode</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">previous</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span> <span class="nx">previous</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">newNode</span><span class="p">;</span> <span class="k">return</span> <span class="nx">list</span><span class="p">;</span> <span class="p">}</span> </code></pre></div></div> <h2 id="deleting-a-node">Deleting a node</h2> <p>To delete a node carrying a specific value, we can rely on <code class="language-plaintext highlighter-rouge">search()</code> to find that node, and <code class="language-plaintext highlighter-rouge">searchPrevious()</code> to find the node immediately prior to that node. We can then link the <em>(n-1)</em>th node to the <em>(n+1)</em>th node.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">deletion</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">x</span><span class="p">){</span> <span class="k">if</span> <span class="p">(</span><span class="nx">list</span><span class="p">.</span><span class="nx">data</span> <span class="o">==</span> <span class="nx">x</span><span class="p">){</span> <span class="k">return</span> <span class="nx">list</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span> <span class="p">}</span> <span class="kd">let</span> <span class="nx">targetNode</span> <span class="o">=</span> <span class="nx">search</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span> <span class="k">if</span> <span class="p">(</span><span class="nx">targetNode</span> <span class="o">==</span> <span class="kc">undefined</span><span class="p">){</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="dl">"</span><span class="s2">does not exist</span><span class="dl">"</span><span class="p">;</span> <span class="p">}</span> <span class="kd">let</span> <span class="nx">previous</span> <span class="o">=</span> <span class="nx">searchPreviousNode</span><span class="p">(</span><span class="nx">list</span><span class="p">,</span> <span class="nx">x</span><span class="p">);</span> <span class="nx">previous</span><span class="p">.</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">targetNode</span><span class="p">.</span><span class="nx">next</span><span class="p">;</span> <span class="k">return</span> <span class="nx">list</span><span class="p">;</span> <span class="p">}</span> </code></pre></div></div></content>
<author>
<name/>
</author>
<category term="programming"/>
<summary type="html">In the previous post, I wrote about the concept of linked lists and how they are different from arrays. In this post, I write about some of the basic operations that can be carried out on a linked list.</summary>
</entry>
<entry>
<title type="html">Linked Lists and Arrays</title>
<link href="https://otee.dev/2021/07/27/data-structures-arrays-and-linked-lists.html" rel="alternate" type="text/html" title="Linked Lists and Arrays"/>
<published>2021-07-27T00:00:00+00:00</published>
<updated>2021-07-27T00:00:00+00:00</updated>
<id>https://otee.dev/2021/07/27/data-structures-arrays-and-linked-lists</id>
<content type="html" xml:base="https://otee.dev/2021/07/27/data-structures-arrays-and-linked-lists.html"><p>In this post, I attempt to understand two of the simplest data structures: arrays and linked lists. But before that, I try to see what a ‘data structure’ actually means.</p> <h2 id="what-is-a-data-structure">What is a data structure?</h2> <p>Broadly, a data structure is a mere collection of data objects or items. More precisely, it refers to the manner of <a href="https://en.wikipedia.org/wiki/Data_structure#cite_note-2">organising, modifying and storing data</a> in a program.</p> <p>Different programs need to carry out different kinds of operations. Given the operation to be carried out, we create the requisite data structure that is most suitable for that task. In some programs, the most significant operation may be to search whether a particular data value exists in a data-set. An array may be well-suited for such a program (as discussed below). While in some other program, we may need to conduct more complicated tasks, that may require more sophisticated data structures than simple arrays. Thus, keeping an eye on the nature of operations to be carried out, data structures are designed accordingly, such that those operations can be completed most efficiently. Thus, we design data structures to serve the needs of the algorithm at hand. In other words, “<em><a href="https://www.amazon.in/Algorithms-Structures-Prentice-Hall-automatic-computation/dp/0130224189">Algorithms + Data Structures = Programs</a>“</em>.</p> <p>Unfortunately, there is <strong>no silver bullet when it comes to data structures</strong>: we cannot design a data structure that is <em>universally efficient</em> regardless of the algorithm at hand. Each kind of data structure provides certain benefits and guarantees, and have other draw-backs.</p> <h2 id="arrays-and-linked-lists">Arrays and Linked lists</h2> <p>Two of the simplest types of data structures are arrays and linked lists. Arrays contiguously stored values. Conceptually, an array is a collection of sequentially arranged data values, that are placed on a specific range of indices or positions. Arrays start from the index of 0 and proceeds incrementally. As arrays come built-in with most programming languages, we do not have to write constructors for arrays. Typically, arrays also have a fixed size (as discussed below) and their contents can be accessed by referring to their position or <em>index</em> within the array.</p> <p>Linked lists are linear data structures, which are not contiguously arranged; instead, each unit, called a ‘node’, is connected to another unit, by way of <em>pointers</em>. A node of a linked list may be placed anywhere in memory, but each node will point to the next node and that node will point to the node thereafter and so on. By way of analogy, the pages containing search results of a search engine act like a linked list: the user can only go to either the next or the previous page from a specific page.</p> <p>As linked lists can be created from scratch, it gives us freedom to design linked lists, which are best suited to the need at hand. A linked list in which each node carries a pointer to only the next or the previous node in the list, is called a <strong>singly-linked list</strong>. Most commonly, singly linked-lists (also called chains) will start with a head node, with each node pointing to the next node, and the last node pointing to <code class="language-plaintext highlighter-rouge">null</code>.</p> <p><img src="/assets/images/singlyLinkedList.jpg" alt="Singly linked list" /></p> <p>When the last node, instead, points to the head node, it will be called a circular linked list:</p> <p><img src="/assets/images/circularLinkedList.jpg" alt="Circular linked list" /></p> <p>Nodes can also carry pointers to <em>both</em> the next and the previous nodes. Such linked lists are called <strong>doubly-linked lists</strong>. A doubly-linked circular list will have the head node pointing to the second node in the list, while also pointing to the last node in the list. Equally, the last node will have two pointers: one pointed to the penultimate node and the other to the head node.</p> <p><img src="/assets/images/doublyLinkedList_Circular.jpg" alt="Doubly linked circular linked list" /></p> <h2 id="space-efficiency">Space Efficiency</h2> <p>Arrays need to contain only the data-items stored within them. However, in the case of linked lists, each node has to also carry a pointer to the next node. Thus, to store the same number of data-items, a linked list will need greater amount of space in the computer’s memory, for each node. In this regard, linked lists have an overhead, in comparison with arrays.</p> <p>However, it is relatively difficult to insert additional items to an array, beyond its fixed allocated size. In other words, it is relatively difficult to add a new element to an array that was created to carry <em>n</em> items and that already contains <em>n</em> item. This is because arrays are contiguously arranged data structures, where each item is placed next to each other on the computer’s memory. Thus, in an array of length <em>n</em>, if we want to add a new element, we have to see if the memory address right after that array is already occupied or not. If yes, it would be very costly to add the <em>(n+1)</em>th item: a new memory location needs to be identified, for containing an array of <em>(n+1)</em> items. Then, all the existing items of the array will need to be copied to the new location and the older memory location will have to be freed. Finally, we can add the <em>(n+1)</em>th item. This may potentially keep happening each time we want to insert newer items to that same array (as we will keep hitting the fixed storage allocated for that array). As all of this happens in the background while working on a programming language like JavaScript, it may feel trivial when writing simple programs. But this may severely impact the efficiency of programs dealing with bigger data-sets, where the cost of copying existing arrays to a new location may lead to severe bottle-necks.</p> <p>Also, in other programming languages, such as C, all of this does not happen in the background. The programmer has to manually request the computer to allocate a bigger memory space when an array reaches its initially allocated capacity. One common work-around while working in such programming languages is to create <em>dynamic arrays</em>, such that each time an array reaches its full capacity (of containing <em>n</em> items), the programmer will request for a memory allocation of <em>2n</em> items, and then copy the exiting items to the first half of the new memory location. Again, when the array reaches its full capacity, a capacity to store <em>2*2n</em> items will be requested and so on. This saves the trouble of requesting allocation of a new memory location for the entire array, for each additional element.</p> <p>While dynamic arrays attempt to reduce the number of times we need to seek a new memory location for inserting additional items, it is not a perfect solution. Also, it may lead a scenario where we are creating large arrays which unnecessarily ‘hold-up’ unused memory space. This could happen, for example, when the length of the array decreases in size subsequently. Thus, if the number of elements in the array subsequently decreases to (<em>4n-m</em>), the array would have an additional unused empty space for m items. <strong>Thus, arrays are not ideal when dealing with data that keep changing</strong> (i.e., for algorithms that require frequent insertions and deletions).</p> <p>However, unlike arrays, insertions and deletions are relatively simpler, as discussed below. And, so long as there is additional space available anywhere in the computer’s memory, we will never reach a point where we reach the maximum storage capacity when dealing with linked lists.</p> <h2 id="accessing-deleting-and-inserting">Accessing, Deleting and Inserting</h2> <h4 id="accessing-data">Accessing Data</h4> <p>Elements in an array can be accessed very efficiently, as they will always be contiguous to each other. Thus, accessing the value stored in a specific index <code class="language-plaintext highlighter-rouge">i</code> will require only one operation. As a practical utility of this feature, if the elements of an array are sorted, finding out elements with the minimum value, maximum value, and median value can be done by one operation each. Additionally, it is convenient to iterate through various elements of an array, as they will always be sequentially arranged. Thus, if we need to check if an element exists within an unsorted array, we can run a simple loop to do this operation.</p> <p>Linked lists, on the other hand, are not very efficient when we need to access specific elements in the list. This is because, it is not permissible to <em>jump to a specific node</em> in the list, as only the <em>(n-1)</em>th node will know the location of the <em>nth</em> node (in the case of singly linked lists). Thus, if we need to know the value contained by the last item in a linked list, we will need to traverse through the entire list, to reach the last node (assuming we do not already have a pointer to the last item saved from a previous iteration).</p> <h4 id="insertions">Insertions</h4> <p>For inserting an element <em>anywhere</em> in a data structure, it is relatively less burdensome to do so in a linked list. In a linked list, we can create a new node, and add its pointer to the head node, such that the newly added node becomes the head node of the list. Thus, if we are dealing with an <em>unsorted linked list,</em> where it is of little significance <em>where we insert</em> a new node, we can insert a new node with a fixed number of operations, irrespective of the length of the list.</p> <p><img src="/assets/images/InsertingANewHead.jpg" alt="Inserting a node in a linked list" /></p> <p>But this is not the case with an array. To insert an element in an array, we may need to shift the entire array to a new memory location, if the immediately next memory location after the size of the array is already taken up (as shown above). Alternatively, if we want to insert the new element at the beginning of the array, we will need to <em>shift</em> <em>each element</em> by one index. Thus, for insertions, arrays may not be the most optimal data structure.</p> <h4 id="deletions">Deletions</h4> <p>Just like insertions, it is relatively simpler to delete nodes in a linked list. Deletions can be executed by changing the pointer of the (<em>n -1</em>)th node to point to the (<em>n + 1</em>)th node, (instead of the <em>n</em>th node) thereby deleting the <em>n</em>th node from the list. Thus, <em>if we have a pointer to the (n-1)th item</em>, we can carry out deletions with a specific set of operations. For example, if we have to delete the head node in a linked list, we can do this by declaring the second node as the head node of the list. Similarly, if we have a pointer to the second-last node of a linked list, we can delete the last node, by changing the pointer of the second-last node to <code class="language-plaintext highlighter-rouge">null</code> .</p> <p><em>However,</em> if we do not have a direct pointer to <em>(n-1)</em>th node, we have to traverse through the entire list, starting with the head node, till we reach that node, and only then can we carry out the deletion operation.</p> <p><img src="/assets/images/deletionLinkedList.jpg" alt="Deleting a node in a linked list" /></p> <p>In the case of arrays, as noted above, if we delete any element, every element following that element will need to be brought-forward by one index.</p> <h2 id="takeaways">Takeaways</h2> <p>From the above discussion, the following can be inferred:</p> <ul> <li> <p>Arrays are better for random access of elements.</p> </li> <li> <p>But they have fixed size. Thus, insertions and deletions are costly.</p> </li> <li> <p>Linked lists take up greater space per unit than arrays, (as they have to store one or more pointers)</p> </li> <li> <p>But linked lists have dynamic size. So insertions and deletions are less burdensome.</p> </li> </ul> <p>In the <a href="/2021/07/28/linked-lists-in-javascript.html">next post</a>, I will discuss how to create linked-lists in JavaScript.</p></content>
<author>
<name/>
</author>
<category term="programming"/>
<summary type="html">In this post, I attempt to understand two of the simplest data structures: arrays and linked lists. But before that, I try to see what a ‘data structure’ actually means.</summary>
</entry>
<entry>
<title type="html">Valid Parenthesis</title>
<link href="https://otee.dev/2021/07/25/valid-parenthesis.html" rel="alternate" type="text/html" title="Valid Parenthesis"/>
<published>2021-07-25T00:00:00+00:00</published>
<updated>2021-07-25T00:00:00+00:00</updated>
<id>https://otee.dev/2021/07/25/valid-parenthesis</id>
<content type="html" xml:base="https://otee.dev/2021/07/25/valid-parenthesis.html"><p>In this post, I discuss how I solved a problem on LeetCode on the correct order of Parentheses.</p> <h2 id="the-problem">The Problem</h2> <p>Quoting the <a href="https://leetcode.com/problems/valid-parentheses/">problem-statement</a>:</p> <blockquote> <p>Given a string s containing just the characters <code class="language-plaintext highlighter-rouge">(</code>, <code class="language-plaintext highlighter-rouge">)</code>, <code class="language-plaintext highlighter-rouge">{</code>, <code class="language-plaintext highlighter-rouge">}</code>, <code class="language-plaintext highlighter-rouge">[</code> and <code class="language-plaintext highlighter-rouge">]</code>, determine if the input string is valid. An input string is valid if:</p> </blockquote> <blockquote> <p>Open brackets must be closed by the same type of brackets.</p> </blockquote> <blockquote> <p>Open brackets must be closed in the correct order.</p> </blockquote> <p>For example, if the input string is <code class="language-plaintext highlighter-rouge">[{}][]</code>, it should return <code class="language-plaintext highlighter-rouge">true</code>. Conversely, if the input string is <code class="language-plaintext highlighter-rouge">[)[{)]</code>, it should return <code class="language-plaintext highlighter-rouge">false</code>.</p> <h2 id="my-attempt">My attempt</h2> <p>I was stuck with this problem for one whole day. I broke down the problem cases (i.e., cases when the return should be <code class="language-plaintext highlighter-rouge">false</code>), in the following three buckets:</p> <ol> <li>When the number of characters in the string is odd (because this would imply that there is at least one incomplete pair of braces).</li> <li>When the number of open brackets do not equal to the number of closed brackets (i.e., if the input is <code class="language-plaintext highlighter-rouge">[[[]</code> it should return <code class="language-plaintext highlighter-rouge">false</code>).</li> <li>Each open bracket should be closed by its corresponding closing bracket. But, if there is any open bracket placed within a pair of brackets, then that bracket should be properly closed <em>before</em> closing the first pair.</li> </ol> <p>While the first two problem cases were easy to eliminate, it was proving to be rather difficult to write the logic for eliminating incorrect bracket-closings, i.e., strings such as <code class="language-plaintext highlighter-rouge">[(])</code>.This example had an even number of braces, and the number of opening brackets equals the number of closing brackets. Heck, even the nature of closing brackets match that of the opening brackets! Its <em>just the order</em> which is misplaced.</p> <p>Eventually, I was about to give up and look into the discussion section. However, incidentally, I was reading a book on data structures, that briefly introduced the concept of stacks and queues. While reading the part on stacks, it struck me that <strong>brackets are always arranged in an last-in-first-out order</strong>. As I had not yet done a deep-dive on stacks and learnt the intricacies of this data structure, I had initially thought that I should delay this problem till I knew enough about this concept.</p> <p>But I couldn’t help myself. Having invested an entire day, and now having visualised this potential solution, I just <em>had to see</em> if I could solve the problem using the last-in-first-out breakthrough. So, this time, for point no. 3 above, I decided to do the following:</p> <ul> <li>For every open bracket I come across in the string (going left-to-right), I would push its complimentary closing bracket in an empty array.</li> <li>For every closing bracket, I would first see if it matches the element that was last pushed into the aforesaid array. If yes, I would delete the last pushed element from that array and continue with the rest of the string. If not, it would imply that the closing bracket is of a kind not matching the last open bracket. This would mean the supplied string was not correctly arranged.</li> </ul> <p>Here’s what I wrote:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">isValid</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="p">{</span> <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">s</span><span class="p">];</span> <span class="kd">let</span> <span class="nx">open</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="kd">let</span> <span class="nx">close</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="kd">let</span> <span class="nx">correctClose</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// checking if the supplied string has an even number of characters</span> <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">length</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="p">}</span> <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// for every open bracket, pushing the corresponding closed bracket into the array named 'correctClose'</span> <span class="k">switch</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span> <span class="p">{</span> <span class="k">case</span> <span class="dl">"</span><span class="s2">{</span><span class="dl">"</span><span class="p">:</span> <span class="nx">correctClose</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="dl">"</span><span class="s2">}</span><span class="dl">"</span><span class="p">);</span> <span class="nx">open</span><span class="o">++</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span> <span class="k">case</span> <span class="dl">"</span><span class="s2">(</span><span class="dl">"</span><span class="p">:</span> <span class="nx">correctClose</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="dl">"</span><span class="s2">)</span><span class="dl">"</span><span class="p">);</span> <span class="nx">open</span><span class="o">++</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span> <span class="k">case</span> <span class="dl">"</span><span class="s2">[</span><span class="dl">"</span><span class="p">:</span> <span class="nx">correctClose</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="dl">"</span><span class="s2">]</span><span class="dl">"</span><span class="p">);</span> <span class="nx">open</span><span class="o">++</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span> <span class="c1">// for every closed bracket, checking if it matches the last pushed element into 'correctClose'</span> <span class="k">case</span> <span class="dl">"</span><span class="s2">]</span><span class="dl">"</span><span class="p">:</span> <span class="k">case</span> <span class="dl">"</span><span class="s2">)</span><span class="dl">"</span><span class="p">:</span> <span class="k">case</span> <span class="dl">"</span><span class="s2">}</span><span class="dl">"</span><span class="p">:</span> <span class="nx">close</span><span class="o">++</span><span class="p">;</span> <span class="k">if</span> <span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">correctClose</span><span class="p">[</span><span class="nx">correctClose</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span> <span class="nx">correctClose</span><span class="p">.</span><span class="nx">pop</span><span class="p">(</span><span class="nx">correctClose</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span> <span class="p">}</span> <span class="c1">// Finally, checking if the number of open brackets and closed brackets are equal to each other</span> <span class="k">return</span> <span class="nx">open</span> <span class="o">==</span> <span class="nx">close</span><span class="p">;</span> <span class="p">};</span> </code></pre></div></div> <p>This solution was accepted by LeetCode. I do not know if this is the most elegant way to solve this problem or if this is the correct implementation of the ‘last-in-first-out’ concept. I will read more to find out. But for now, I am very proud with myself for being able to solve this problem without relying on the discussion section of LeetCode.</p></content>
<author>
<name/>
</author>
<category term="programming"/>
<summary type="html">In this post, I discuss how I solved a problem on LeetCode on the correct order of Parentheses.</summary>
</entry>
<entry>
<title type="html">Palindrome</title>
<link href="https://otee.dev/2021/07/20/palindrome.html" rel="alternate" type="text/html" title="Palindrome"/>
<published>2021-07-20T00:00:00+00:00</published>
<updated>2021-07-20T00:00:00+00:00</updated>
<id>https://otee.dev/2021/07/20/palindrome</id>
<content type="html" xml:base="https://otee.dev/2021/07/20/palindrome.html"><p>In this post, I discuss my experience of solving my <em>very first</em> problem on LeetCode.</p> <h2 id="the-problem">The Problem</h2> <p>To write a program that can check if an integer is a <a href="https://leetcode.com/problems/palindrome-number/submissions/">palindrome or not</a>. It was also provided that negative integers and integers ending with one or more zeroes would be deemed to be non-palindromes.</p> <p>It was suggested that the program be written without converting the integer to a string (though this was not mandatory).</p> <h2 id="my-attempt">My Attempt</h2> <p>I solved this problem using a <code class="language-plaintext highlighter-rouge">for-loop</code>:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">isPalindrome</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="p">}</span> <span class="kd">let</span> <span class="nx">lastDigit</span> <span class="o">=</span> <span class="nx">x</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span> <span class="k">if</span> <span class="p">(</span><span class="nx">lastDigit</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">==</span> <span class="nx">lastDigit</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span> <span class="p">}</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="p">}</span> <span class="kd">let</span> <span class="nx">reverse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">x</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">i</span> <span class="o">/</span> <span class="mi">10</span><span class="p">))</span> <span class="p">{</span> <span class="nx">reverse</span> <span class="o">=</span> <span class="nx">reverse</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="p">(</span><span class="nx">i</span> <span class="o">%</span> <span class="mi">10</span><span class="p">);</span> <span class="p">}</span> <span class="k">if</span> <span class="p">(</span><span class="nx">reverse</span> <span class="o">==</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span> <span class="p">}</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="p">};</span> </code></pre></div></div> <h2 id="is-there-a-better-way-to-solve-this-problem">Is there a better way to solve this problem?</h2> <p>Although my solution was accepted by LeetCode, I was curious if there was a more elegant solution that took a lesser run-time or required lesser memory to do the same task. So, I looked into some of the solutions posted by others on the discussion section of LeetCode.</p> <p>Taking a cue from some of the solutions, I figured a better way to write the same program. I realised that the key is to run the loop <em>only till the half-way point</em>.</p> <h4 id="when-x-is-an-even-number">When x is an even number</h4> <ul> <li>First, we start with <code class="language-plaintext highlighter-rouge">reverse = 0</code> , and <code class="language-plaintext highlighter-rouge">x</code> is the original value</li> <li>At each iteration, we increase <code class="language-plaintext highlighter-rouge">reverse</code> by the last digit in <code class="language-plaintext highlighter-rouge">x</code></li> <li>At the same time, we reduce <code class="language-plaintext highlighter-rouge">x</code> by its last digit, as well</li> <li>Thus, at each iteration, <code class="language-plaintext highlighter-rouge">reverse</code> <em>gains a digit</em> and <code class="language-plaintext highlighter-rouge">x</code> <em>loses a digit</em>.</li> <li>During the course of the loop, there would be three stages, where <code class="language-plaintext highlighter-rouge">x</code> is a palindrome: <ul> <li><code class="language-plaintext highlighter-rouge">x</code> &gt; <code class="language-plaintext highlighter-rouge">reverse</code></li> <li><code class="language-plaintext highlighter-rouge">x</code> == <code class="language-plaintext highlighter-rouge">reverse</code></li> <li><code class="language-plaintext highlighter-rouge">reverse</code> &gt; <code class="language-plaintext highlighter-rouge">x</code></li> </ul> </li> <li>Now, <em>for non-palindromes</em>, the second step will be skipped. In other words, when both <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">reverse</code> have the <em>same number of digits</em> , they will still be unequal.</li> <li>Given this, to determine the mid-point of the integer, we cannot rely on a condition where <code class="language-plaintext highlighter-rouge">x</code> == <code class="language-plaintext highlighter-rouge">reverse</code> (because not all <code class="language-plaintext highlighter-rouge">x</code>s will be palindromes). So we identify the mid-point by seeing when <code class="language-plaintext highlighter-rouge">reverse</code> becomes either greater than or equal to <code class="language-plaintext highlighter-rouge">x</code></li> <li>Thus, the <strong>loop should run only when <code class="language-plaintext highlighter-rouge">x &gt; reverse</code></strong>, i.e., it will stop, the moment either <code class="language-plaintext highlighter-rouge">x == reverse</code> (in case of a palindrome) or <code class="language-plaintext highlighter-rouge">x &lt; reverse</code></li> <li>Once the loop is terminated, if <code class="language-plaintext highlighter-rouge">reverse</code> == <code class="language-plaintext highlighter-rouge">x</code> , then its a palindrome</li> </ul> <p><img src="/assets/images/evennumbers_palindrome.jpg" alt="Table the iteration of the loop where x is an even number" /></p> <h4 id="when-x-is-an-odd-number">When x is an odd number</h4> <ul> <li>Even when <code class="language-plaintext highlighter-rouge">x</code> is an odd number, the same loop should be used. But note that in odd palindromes, the middle number is not repeated (eg. 12<strong>1</strong>21).</li> <li>So, during the iteration of the loop, there will not come a time where the <code class="language-plaintext highlighter-rouge">reverse</code> and <code class="language-plaintext highlighter-rouge">x</code> will actually be equal to each other (even when <code class="language-plaintext highlighter-rouge">x</code> is a palindrome)</li> <li>Thus, the point for terminating the loop should be determined by seeing when <code class="language-plaintext highlighter-rouge">x</code> ceases to be greater than <code class="language-plaintext highlighter-rouge">reverse</code>. [In the case of odd numbers, this will happen when the <code class="language-plaintext highlighter-rouge">reverse</code> accumulates more digits than <code class="language-plaintext highlighter-rouge">x</code>, because there will never be a point when both <code class="language-plaintext highlighter-rouge">reverse</code> and <code class="language-plaintext highlighter-rouge">x</code> have the same number of digits]</li> <li>After the loop is terminated, to see whether <code class="language-plaintext highlighter-rouge">x</code> is a palindrome, we will need to <em>ignore the middle number</em>, and then compare the <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">reverse</code>.</li> </ul> <p><img src="/assets/images/oddnumbers_palindrome.jpg" alt="Table the iteration of the loop where x is an even number" /></p> <h4 id="comparing-x-with-reverse">Comparing x with reverse</h4> <p>After the loop is terminated, we should see if <code class="language-plaintext highlighter-rouge">x == reverse || x == Math.Floor(reverse/10</code>), to see if <code class="language-plaintext highlighter-rouge">x</code> is in fact a palindrome. [In the case of an odd number, <code class="language-plaintext highlighter-rouge">reverse</code> will always have an extra digit (i.e., the middle digit). Thus, while comparing the two, we should see if <code class="language-plaintext highlighter-rouge">reverse</code> without its last digit equals to <code class="language-plaintext highlighter-rouge">x</code>].</p> <p>Putting everything together:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">reverse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">while</span> <span class="p">(</span><span class="nx">x</span> <span class="o">&gt;</span> <span class="nx">reverse</span><span class="p">)</span> <span class="p">{</span> <span class="nx">reverse</span> <span class="o">=</span> <span class="nx">reverse</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="p">(</span><span class="nx">x</span> <span class="o">%</span> <span class="mi">10</span><span class="p">);</span> <span class="nx">x</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">x</span> <span class="o">/</span> <span class="mi">10</span><span class="p">);</span> <span class="p">}</span> <span class="k">if</span> <span class="p">(</span><span class="nx">reverse</span> <span class="o">==</span> <span class="nx">x</span> <span class="o">||</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">(</span><span class="nx">reverse</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">true</span><span class="p">;</span> <span class="p">}</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="p">};</span> </code></pre></div></div></content>
<author>
<name/>
</author>
<category term="programming"/>
<summary type="html">In this post, I discuss my experience of solving my very first problem on LeetCode.</summary>
</entry>
</feed>"`;

import { JSDOM } from "jsdom";
const parsed = new JSDOM(xml);
console.log(parsed.window.document);

//The getElementById() method returns the element that has the ID attribute with the specified value.
let listOfEntries = parsed.window.document.getElementsByTagName("entry");
let listOfTitles = parsed.window.document.getElementsByTagName("title");//should generate a list of titles.  


let allPosts = [];
for(let i = 0; i < listOfEntries.length; i++){
    let currentPost = {};
    currentPost.title = listOfEntries[i].getElementsByTagName("title")[0].innerHTML;
    currentPost.date = listOfEntries[i].getElementsByTagName("published")[0].innerHTML;
    currentPost.content = listOfEntries[i].getElementsByTagName("content")[0].innerHTML;
    currentPost.link = listOfEntries[i].getElementsByTagName("id")[0].innerHTML;
    allPosts.push(currentPost);
}
console.log(allPosts);