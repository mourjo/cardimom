import * as filter from "../src/filter.js";
import * as assert from "assert";

let listOfPosts1 = [
  {
    title: "Crisp: A Simple Lisp Interpreter",
    date: 1629244800000,
    content:
      "In this post, I discuss about building a simple Lisp interpreter, written in JavaScript, supporting basic Clojure syntax.</p> <h2 id=infix-expressions-and-operator-precedence>Infix Expressions and Operator Precedence</h2> <p>In arithmetic expressions, the operator is always placed <em>in between</em> the operands. For example, an expression to multiply <code class=language-plaintext highlighter-rouge>2</code>, <code class=language-plaintext highlighter-rouge>3</code> and <code class=language-plaintext highlighter-rouge>4</code> would be written as follows: <code class=language-plaintext highlighter-rouge>2 * 3 * 4</code>. Because the operator is sandwiched between operands, these expressions are also called <strong>infix</strong> expressions.</p> <p>But when there are different operators in a single expression, it can result in some confusion. Take, for example, the expression, <code class=language-plaintext highlighter-rouge>2 * 3 + 4</code>. If <code class=language-plaintext highlighter-rouge>2</code> and <code class=language-plaintext highlighter-rouge>3</code> are multiplied first and then <code class=language-plaintext highlighter-rouge>4</code> is added, the result would be <code class=language-plaintext highlighter-rouge>10</code>. However, if <code class=language-plaintext highlighter-rouge>3</code> and <code class=language-plaintext highlighter-rouge>4</code> are added first and then multiplied by <code class=language-plaintext highlighter-roug>2</code>, the result would be <code class=language-plaintext highlighter-rouge>14</code>.</p> <p>To prevent this kind of confusion, there is a collection of rules, called <strong>operator precedence</strong>, that have evolved ever since the introduction of algebraic notation, that dictate the order of precedence among operators",
    link: "https://otee.dev/2021/08/24/crisp-a-simple-lisp-interpreter.html",
  },
  {
    title: "Cache Replacement",
    date: 1629244800000,
    content:
      "It is said that “There are two hard things in computer science: cache invalidation, naming things, and off-by-one errors.” This post will be on the first one. In this post, I attempt to discuss what the term ‘cache’ actually means and delve into some of the common cache replacement policies. Also, inspired by this Clojure repository on Github, I attempt to implement some of the common cache replacement policies. What is cache? Cache refers to the storage of data that is likely to be requested in the future. When an application needs to access some data (which is expected to be cached), it will first check if that data exists in its cache. If yes, it will simply retrieve that data and access it. Otherwise, it will generate that data, which will be stored in the cache for a future request. When the data requested from a cache is successfully found, it is called a cache hit. On the other hand, a cache miss occurs when the requested data is not stored in the cache. In the event of a cache miss, the data will need to be computed or located from a slower data source, which will take much longer time to generate, than a cache hit. For example, a browser may download web-pages that are most-frequently used by the user. When requests for those web-pages are generated by the user, the browser can simply retrieve the downloaded pages which will be much faster than loading other web-pages which are not cached. Thus, it is clear that, ideally, the number of cache hits should, on an average, be greater than the number of cache misses. This makes the hit ratio of cache very crucial. Problem with unrestricted memoization In a world with infinite resources to store infinite amount of data, we can achieve a near-perfect hit ratio, as we can keep populating our cache with the data generated from previous requests, thereby restricting cache misses to only those requests that have never been created before. In my previous post on memoization, I had implemented exactly this. Recall that memoization refers to the storage of return values of previous function-calls. I had implemented memoization such that whenever a memoized function was called with a given set of arguments, that function would first check if a return value for that set of arguments already existed in a dictionary called memo. If the memo did not contain the return value, it would compute the value by calling the actual function, and then indiscriminately store that value against the set of arguments, before returning the value back to the caller. In this way, we simply stored each and every input and return values of a memoized function. This approach proved to be particularly effective with functions which recursively called itself more than once (such as a function to generate the nth Fibonacci number). But, inadvertently, the memo dictionary (storing the return values), kept growing with each new set of inputs. For example, when we call the memoized Fibonacci function with 50 as an argument, the memo would store the return values of every integer from 0 till 50. This is not ideal, because when dealing with larger data-sets and more complicated algorithms, we will not have the luxury to store each and every return value.",
    link: "https://otee.dev/2021/08/18/cache-replacement-policy",
  },
  {
    title: "Pale blue dot: A Covid-19 perspective",
    date: 1629244800000,
    content:
      "In his famous book “The pale blue dot”, Carl Sagan wrote about our unremarkable position in the Universe as human beings. This photo shows the pale blue dot; the image taken by the space probe Voyager 1 on February 14, 1990. As the spacecraft left our planetary neighborhood for the fringes of the solar system, NASA turned it around for one last look at our home planet. As the world plunges into the unthinkable crisis of Covid-19, it is hard to find hope and courage to dream of a better day. Everything we know and love, our way of life, has reached a point of existential crisis. While many of our livelihoods are affected, many others are paying the dearest price of having to lose their loved ones. Look again at that dot. That’s here. That’s home. That’s us. On it everyone you love, everyone you know, everyone you ever heard of, every human being who ever was, lived out their lives. The aggregate of our joy and suffering, thousands of confident religions, ideologies, and economic doctrines, every hunter and forager, every hero and coward, every creator and destroyer of civilization, every king and peasant, every young couple in love, every mother and father, hopeful child, inventor and explorer, every teacher of morals, every corrupt politician, every superstar, every supreme leader, every saint and sinner in the history of our species lived there–on a mote of dust suspended in a sunbeam.",
    link: "https://mourjo.me/blog/non-tech/2020/05/12/pale-blue-dot",
  },
];
describe("test filter", () => {
  it("list of Posts", () => {
    assert.equal(filter.select(listOfPosts1, [], ["xxx"]), listOfPosts1);

    // assert.equal(filter.config_reader("path2"), []);
    // assert.equal(interpreter.lisp("(* 5 4 3 2 1)"), 120);
    // assert.equal(interpreter.lisp("(* 5 \n 4 \n 3 2 1)"), 120);
    // assert.equal(interpreter.lisp("(/ 2 3)"), 2 / 3);
  });

  // it("Nested expressions", () => {
  //   assert.equal(interpreter.lisp("(+ (* 8 9) 9)"), 81);
  //   assert.equal(interpreter.lisp("(* 10 (+ 11 12) 13)"), 2990);
  //   assert.equal(interpreter.lisp("(+ 1 (* 2 3) (* 4 2))"), 15);
  //   assert.equal(interpreter.lisp("(+ -1 (* -2 3) (* 4 2))"), 1);
  //   assert.equal(interpreter.lisp("(- (+ 1 2 3) (+ 1 2 3))"), 0);
  //   assert.equal(interpreter.lisp("(* (+ 1 2 3) (+ 1 2 3))"), 36);
  //   assert.equal(interpreter.lisp("(/ (+ 1 2 3) (+ 1 2 3))"), 1);
  // });

  // it("Valid Expressions with variables", () => {
  //   assert.equal(interpreter.lisp("(def n 11) (def m 100) (* n m)"), 1100);
  //   assert.equal(
  //     interpreter.lisp(
  //       "(def height 10) (def width (+ height 4)) (def height 11) (* height width)"
  //     ),
  //     154
  //   );
  //   assert.equal(interpreter.lisp("(+ 1 (def nine 9) (* 4 2) nine)"), 27);
  //   assert.equal(interpreter.lisp("(* 1 (def nine 9) (* 4 -2) nine)"), -648);
  //   assert.equal(interpreter.lisp("(def nine 9)"), 9);
  //   assert.equal(interpreter.lisp("(+ (def nine 9) (def n nine))"), 18);
  //   assert.equal(interpreter.lisp("(def nine 9) (def n nine)"), 9);
  // });

  // it("Invalid expressions", () => {
  //   assert.ok(checkInvalidExpression("(* 9"));
  //   assert.ok(checkInvalidExpression("(* (+ 9"));
  //   assert.ok(checkInvalidExpression("(+ & 6)"));
  //   assert.ok(checkInvalidExpression("(! 5 4 3 2 1)"));
  //   assert.ok(checkInvalidExpression("(* 5 4 3 2 1))"));
  //   assert.ok(checkInvalidExpression("((def nine 9) (def n nine))"));
  //   assert.ok(checkInvalidExpression("(* 11 11"));
  //   assert.ok(checkInvalidExpression("(((("));
  //   assert.ok(checkInvalidExpression("((())"));
  // });
});
